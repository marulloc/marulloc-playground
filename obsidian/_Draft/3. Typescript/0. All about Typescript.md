

https://www.youtube.com/watch?v=kMuJz6N-Grw



- [x] Typescript 
	- [x] 특징 말해주세요 
		- 타입스크립트는 자바스크립트의 SuperSet으로 JS에 정적 타입 선언을 추가한 언어 입니다
		- TypeScript의 컴파일러가 코드 검사를 마치면 타입을 _삭제해서_ 결과적으로 "컴파일된" 코드를 만듭니다. 즉 런타임에 아무런 영향 없다.  
		- [x] SuperSet인 이유 
			- "상위 집합(Superset)"은 기존 집합의 모든 요소를 포함하면서 추가적인 요소나 기능을 제공하는 더 큰 집합을 의미합니다. JS 모든 동작이 가능하지만 거기어 정적 타입을 추가한거니까 
		- [x] 정적 타입 vs 동적타입 
			- 정적 : 변수의 타입이 컴파일 시간에 결정 -> 컴파일 시간에 타입 오류 발견 가능
			- 동적 : 변수의 타입이 실행 시간에 결정되며, 변수에 다양한 타입의 값이 할당될 수 있음  -> 유연성은 있으나 에러발생 확률 높음
 
		
	- [x] 타입체커가 하는일 
		- [x] 타입검사 
			- 변수와 표현식 타입 검사 
			- 리터럴 타입 추론
			- 함수 호출 문의 인수와 함수 선언에 명시된 매개변수 타입 검사, 제네릭 검사
		- [x] 타입호환 : (Duck Typing / 구조적 타이핑) 에 따른다
			- https://toss.tech/article/typescript-type-compatibility 
			- 타입간의 호환성을 판단하는 것
			- 타입 검사의 안정성과 유연함 사이에서 절충안으로 도입된 개념이 타입 호환성
				- 개발자 의도에 따라 유연하게 타이핑 가능
			- TS 는 오직 멤버만으로 타입을 관계 :
				- y가 최소한 x와 동일한 멤버를 가지고 있다면 x와 y는 `호환` 
			
			- [x] 명목적 타이핑 (Java) 과 차이
				- 명목적 타이핑은 타입 정의 시에 상속 관계임을 명확히 명시한 경우에만 타입 호환
				- 구조적 서브타이핑은 아래와 같이 상속 관계가 명시되어 있지 않더라도 객체의 프로퍼티를 기반으로 사용처에서 사용함에 문제가 없다면 타입 호환을 허용
	
			- [x] 타입호환 예외조건  `Fresh Literal`
				- 함수에 값을 바로 인자로 전달하는 경우만 타입 호환이 지원되지 않는다
				- 함수에 값을 바로 넘겨주는 것을 TS는 FreshLiteral 이라고 명명하는데
					- `fresh`
						- 모든 object literal은 초기에 “fresh” 하다고 간주되며, `타입 단언` (type assertion) 을 하거나, `타입 추론`에 의해 object literal의 타입이 확장되면 “freshness”가 사라지게 됩니다. 
						- 특정한 변수에 object literal을 할당하는 경우 이 2가지 중 한가지가 발생하게 되므로 “freshness”가코드를 읽는 다른 개발자의 입장에서 함수가 실제 다루는 것보다 더 많은 데이터를 받아들인다는 오해를 불러일으킬 수 있고, 프로퍼티 키에 대한 오타가 발생하더라도 오류가 확인되지 않는 부작용이 있다고 판단해서 TS는 freshLiteral은 타입호환을 지원하지 않음
						
			- [x] 타입호환 못하게하기 (Branding Type)
				- 의도적으로 `__brand` 와 같은 프로퍼티를 추가시켜, 개발자가 함수의 매개변수로 정의한 타입 외에는 호환이 될 수 없도록 강제하는 기법입니다.
				- `type Brand<K, T> = K & { __brand: T};` 
				- `type Food = Brand<{name : string },'FOOD'>`
		- [x] 타입추론
			- 타입 추론이란 타입이 정의되어 있지 않은 변수의 타입을 자동으로 추론하는 타입스크립트의 기능
			- 타입 추론 덕분에 모든 변수에 일일이 타입을 정의하지 않아도 되는 편리함을 준다.
				- [ ] 타입추론 가능한 상황
					- 변수 선언
					- 구조 분해 할당
					- 함수 반환 값
					- 기본값 설정된 매개변수 
			- 인터페이스 타입 추론
				- 각각의 interface로 이뤄진 객체 배열의 타입은 : 공통된 interface[ ] 형태로 추론됨
 
	- [x] 타입스크립트 잘 쓰기 
		- [x] 타입단언 : `as`
			- 타입스크립트가 **추론하지 못하는 타입을 개발자가 직접 명시해주는 문법** 
			- 타입 단언에도 조건이 있는데, `value as Type` 으로 표현된 단언식에서 
			  `value` 가 `Type` 의 슈퍼타입이거나 서브타입이어야 한다.
			- 다중단언
				- `const num = 10 as unknown as string;`
			- const 단언 
				- `let num 10 as const`
		- [x] 타입가드 : 
			- **유니온 타입을 사용**하면서, **복수의 타입들 중 어느 타입을 이용할 지 확신**을 주는 문법
			- 타입가드에 사용할 수 있는 문법 
				- `typeof`
				- `instanceOf`
				- `in` 
			- `const isString(test:any) : test is string => typeof test === "string"`
			- 
		- [x] Template Literal Type
			- https://toss.tech/article/template-literal-types
			- 템플릿 리터럴을 이용해 새로운 Type을 만드는 것 
			- 유니온 타입을 연결하여 타입을 중복 정의하는 것을 막을 수 있다.
	- [x] ___ 기본 질문
		- [x]  any 임시용, unknown, never, void  타입의 차이점과 사례는 뭐냐
			- never : 함수가 항상 throw 하거나 무한루프 빠지는 함수 
			- void : 아무런 값을 반환하지 않을때
			- unknow : 동적인 타입일때 
		- [x] 언제 enum 사용 사례랑 장점은 뭐냐  
			- 상수 값의 집합으로 사용 
				- 문자형 열거형으로도 가능  `enum DIR { UP = 'UP' , down = "DOWN" }`
				- 숫자형 열거형 가능 `enum AA { Mon, Tue } 얘네는 0과 1로` 
					- `AA.Mon`
		- [x] 조건부 타입은  
			- 삼항연산자처럼 쓰는것
				- `type IsNumber<T> = T extends number ? "Yes" : "No"`
				- `type Result1 = IsNumber<42>; // "Yes"`


	- [x] 얘네 먼저
		- [x] type vs interface
			- interface : extends로 확장 가능, 오버로딩 됨, 컴파일시 캐싱됨
				- extends로 확장
				- 컴파일시 캐싱됨
				- 이름 중복 됨 - 병합됨
			- type 
				- 인터섹션으로 확장 - 컴파일시 & 연산 해야함
				- 원시타입도 선언 가능 
				- 이름 중복 안됨
		- [x] 인덱스시그니쳐  `{[key: T]: U}` 와 `Record`,  
			- 인덱스 시그니처는 동적 데이터를 작성할 때 매우 유용하다.
			- 근데 모든 키 값을 허용한다는 단점
			- 특정 key는 다른 타입을 가질 수도 있을 때 수정 할 수 없음
			- 자동완성기능안됨
		- [x] 제네릭
			- **타입(Type)을, 그 클래스나 함수를 사용할 때 결정하는 것**
			- [x] `Record`
				- 키 타입에 유연성을 제공하는 제너릭 타입이다.
				- `type Vec3D = Record<'x' | 'y' | 'z', number>;` 
		- [x] 유틸리티타입
			- 유틸리티 타입은 이미 정의해 놓은 타입을 변환할 때 사용하기 좋은 타입 문법
			- `Pick` , `Omit` , `Partial
		- [x] 유니온타입 인터섹션타입
			- 인터섹션 : 인터섹션 타입(Intersection Type)은 여러 타입을 모두 만족하는 하나의 타입
			- 유니온 :  A이거나 B이다
			- [x] 유니온타입 주의할 점
				- 사실 유니온은 OR 처럼보이는데 OR 연산이 아니다. 
				- 함수 인자 하나에 유니온타입 `A | B` 가 넘어온다고 정의했을때 타입스크립트 관점에는 호출시점에 뭐가 올지 몰라서 , 둘다 되는 방향으로 타입추론이 이뤄져 에러가 발생하지 않는다. 그래서 마치 인터섹션 타입을 넘긴것 처럼 동작하는데
				- 이것을 해결하려면 `타입가드`를 사용하거나 `브랜딩타입`을 사용해야된다
