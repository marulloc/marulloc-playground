> 배열에 


# Prototype
---
> 원형 객체를 "복제"하여 새로운 객체를 생성하는 것이 아니라
> Prototype Link를 이용해서 원형을 "참조"하는 형태로
> 상속을 구현할 수 있게 해주는 JS 문법이다.




### Prototype Link
---
>  객체의 원형을 참조하는 `__proto__` 내부 프로퍼티를 `Prototype Link`라고 부른다. 

1. 원래 함수를 하나 선언하면, 그에 맞는 Prototype Object라는 `객체의 원형`이 생성된다. 
	- 선언된 함수에는 `propoerty` 라는 내부프로퍼티가 존재하고
	- PropertyObject 에는 `constructor` 라는 내부 프로퍼티가 존재한다.
	- 그리고 각 내부프로퍼티로 서로를 참조한다. 

2. 위 상황에서, `new` 키워드로 함수를 호출하면, 함수는 `생성자`로서 호출된다. 
	- 생성자함수로 호출이 되면, 함수의 `this`는 특별하게, 함수 자신의 스코프를 가리키게된다.
	- 그리고 함수와 동일한 프로퍼티를 가진 `객체`를 반환하게된다. (return문 없어도)

3. 생성자로부터 반환된 `객체`들은
	- `__proto__`라는 내부프로퍼티를 가지게 된다.
	- `__proto__`로 Property Object(`객체의 원형`)을 참조하게 된다. 
 
> 모든 리터럴로 만드는 객체들을 사실 다 내부적으로는 new 를 통해 만들어지는 것임 




### Prototype Chain 
---
> `__proto__`라는 내부 프로퍼티를 통해, 객체의 원형을 참조할 수 있는 "관계"를 얘기한다. 

- 배열이 담긴 변수가 있을때, 우리는 선언한 적도 없는 배열의 메소드를 사용 할 수 있다. 
	- 이것은 Prototype Chain 덕분이다.


1. JS 엔진은 함수가 실행될때는 스코프체인을 이용하지만 , 객체의 내부에서 식별자 해결을 진행할 때는 `Prototype Chain`을 이용한다. 
2. 객체 내부에서 식별자 해결을 진행하다가, 
	- 못찾으면 `__proto__` 가 참조하는 객체의 원형(Prototype Object) 에서 식별자 해결을 진행하고
	- 또 못찾으면 그 객체원형의 객체원형으로 올라가면서 식별자해결을 진행한다. 
3. 내 자신의 것도 아닌 메소드를 쓰지만, 정확히 객체 내에 존재하는 값으로 메소드가 동작하는 이유는
	- 보통 `[1,2,3].map()`으로 호출하는데, 결국 호출되는 함수의 this는 호출 시점에 바인딩 되기 때문

