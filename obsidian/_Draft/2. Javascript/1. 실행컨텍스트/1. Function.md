- 일급객체
- 실행컨텍스트로도 사용되고
- new 키워드와 함께 생성자로도 사용된다.

- 선언문과 표현식 - 호이스팅 차이 있고
- 실행컨텍스트 선언적환경레코드에 함수가 key:value로 저장되는 것에 따라, 함수 오버로딩이 안된다.



# [0] 일급객체
---
일급 객체(first-class object)란 생성, 대입, 연산, 인자 또는 반환값으로서의 전달 등 프로그래밍 언어의 기본적 조작을 제한없이 사용할 수 있는 대상을 의미한다. **Javascript의 함수는 일급객체이다.**
	1. 무명의 리터럴로 표현이 가능하다.
	2. 변수나 자료 구조(객체, 배열 등)에 저장할 수 있다.
	3. 함수의 매개변수에 전달할 수 있다.
	4. 반환값으로 사용할 수 있다.



# [1] 함수 호이스팅
---
- **함수 선언문:** 실행 컨텍스트의 선언 단계에서는 환경 레코드(Environment Record) 내에 함수 선언문이 미리 처리됩니다. 이 단계에서 함수 선언문으로 정의된 `함수의 이름과 함수 본문이 환경 레코드에 등록 (바로 초기화까지 됨)`됩니다. 함수 전체가 이 단계에서 처리되기 때문에, 함수 선언문은 코드 상의 위치와 관계없이 어디서든 호출할 수 있습니다(이것이 호이스팅의 일부입니다).

- **함수 표현식(즉시 실행 함수 포함):** 함수 표현식은 그것이 코드 상에서 평가되는 시점에 함수 객체가 생성됩니다. 즉시 실행 함수의 경우, 함수 표현식이 평가되자마자 바로 실행되며, 이 과정에서 함수 본문이 평가되고 실행됩니다.


> 함수 선언식은 호이스팅되며 함수 표현식은 호이스팅 되지 않는다.  



# [2] 함수 오버로딩이 안되는 이유 
---
> JS에서 함수 오버로딩이 안되는 이유 => KEY:VALUE 형태로 저장되니까




# [3] 함수 인자와 실행 컨텍스트 
---
함수가 호출되는 시점에 호출할때 인자들을 arguments 라는 객체를 만들어 인자들을 삽입한다.
이 arguments는 Array-like 객체로 실제 Array Built-in Object는 아니다. 

이 arguments 객체는 직접적으로 선언적 환경 레코드에는 저장되지 않지만
함수 내부에서 사용할 수 있는 지역변수 처럼 동작한다. 

근데 ES6 의 화살표 함수에서는 자신의 arguments를 생성하지 않고 부모의 arguments 참조한다고 한다..

> Argument가 순차적으로 맵핑되어 인자를 여러개 넘겨도 에러가 발생하지 않음

