

# Closure 
---

> 클로저는 내부 Scope와 외부 Scope , 
> 즉 실행컨텍스트의 선언적 환경 레코드와 외부 렉시컬 환경 참조의 조합으로 이뤄진 환경이다. 


클로저는 함수가 선언될 때의 렉시컬 스코프를 기억하고,
JS 엔진의 식별자 해결 매커니즘을 이용하여
함수가 실행될 때 어디서 실행되든 그 스코프에 접근할 수 있게 해줍니다.

React에서 보면 HOC나 
한 hook에서 리턴하는 컴포넌트가 hook내부의 state를 쓰고 있는 경우에 
이 클로져를 이용하게 된다. 


- 커스텀훅에서 함수를 반환하면 클로져지 


# IIFE
---
> 즉시실행함수는 정의되자마자 즉시 실행되는 함수로
> 클로져와 함께써써 getter setter를 두고 중요정보를 캡슐화 할 수 있다.


- 그룹핑 연산자가 함수 선언문을 함수 표현식으로 만들어버린다. 
	- 그룹핑 연산자에 감싸진 무명함수는,  실행시점에 바로 평가되고 그 반환은 함수가 된다. 
	- 그리고 바로 이어진 호출문으로 함수 결과를 반환하게 된다.
	
- JS엔진은 함수 내부에 쓰인 변수와 함수만 힙에 놔두고, 무명함수 자체를 메모리에서 날린다. 
	- 그래서 다시 그 즉시실행함수에 접근 할 수 없고 재실행 할 수 없다. 

 






즉시 실행 함수(IIFE, Immediately Invoked Function Expression)는 정의되자마자 즉시 실행되는 자바스크립트 함수 패턴입니다.

`그룹핑 연산자`는 소괄호 안의 표현식을 평가하고 결과를 반환하는데 이 안에 `익명함수`가 존재하면 
1. JS엔진은 소괄호 안을 평가하게 되는데 function 키워드로 인해 엔진은 함수 객체를 생성하고 반환하며
2. 이후 뒤에 따라붙은 소괄호에 의해 즉시 호출되면서 실행컨텍스트가 생성되고 콜스택에 push되면서 함수가 실행되게됩니다.

여기서 즉시실행함수는 표현식이며 익명함수기 때문에 부모의 Scope에 어떤 식별자로도 등록될 수 없으며 (선언되지 않음) 그에 따라 기존에 실행된 함수 객체를 다시 참조할수는 없습니다.  

1. **독립적인 스코프 생성:** IIFE는 함수로 감싸진 코드 블록을 즉시 실행함으로써, 이 코드 블록 내에 선언된 모든 변수와 함수는 IIFE의 지역 스코프 내에 존재하게 됩니다. 따라서 이들 식별자는 IIFE 외부에서 접근할 수 없습니다
2. **변수의 캡슐화:** IIFE 내부에서 선언된 변수들은 IIFE의 지역 변수로 취급되므로, 전역 스코프에 추가되지 않습니다. 이로 인해 전역 변수의 수를 최소화할 수 있으며, 전역 네임스페이스의 오염을 방지합니다.
3. **모듈 패턴의 구현:** 모듈 시스템이 표준화되기 전, IIFE는 모듈 패턴의 구현체로 널리 사용되었습니다. IIFE를 사용하여 모듈 내의 세부 구현 사항을 숨기고(캡슐화), 모듈의 공개 인터페이스만을 전역 스코프에 노출시킬 수 있습니다. 이는 모듈 간의 충돌을 방지하고, 코드의 재사용성과 유지보수성을 높일 수 있습니다.


 > 그룹핑연산자로 감싸지 않으면 어떤 일이 벌어지는가 ? 
 > 
 > 그룹핑 연산자(`()`) 없이 익명 함수를 즉시 실행하려고 시도하면 문법 오류가 발생합니다. 
 > 이유는 자바스크립트 파서가 `function` 키워드를 만나면 기본적으로 함수 선언으로 해석하는데 
 > 함수 선언은 이름이 필요하여 에러가 발생하게 됩니다. 
 > 
 > 그룹핑 연산자는 함수를 표현식으로 변환하는 역할을 합니다.  
 > 즉 엔진에게 표현식 내에서 함수를 평가해야 함을 지시하는 것입니다.

> 함수를 평가하다 ?
> "함수를 평가한다"라는 표현은 함수의 코드를 해석하고 처리하는 과정을 말한다.

> 즉시실행함수의 this도 일반함수처럼 얘가 호출되는 곳의 주체이니까 얘는 
> strictmode가 아닐때는 global scope를 참조하겠네? 
> 화살표 함수라면 즉시실행함수 특성상 바로 실행되니까 즉시실행함수가 존재하는 부모의 this를 상속해오고 ?