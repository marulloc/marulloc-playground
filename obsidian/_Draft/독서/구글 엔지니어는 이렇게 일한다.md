# **요약**

---

## **Chapter 2. 팀워크 이끌어내기 ***

위대한 소프트웨어는 위대한 팀에서 만들어진다. 위대한 팀의 일원이 되기 위해 보통 개발자들의 생각을 알고 나 또한 그들과 다르지 않음을 아해하는 것이 매우 중요하다.

### 2.1 개발자들

개발자들은 보통 자신이 진행 중인 코드로 판단을 받기 싫어한다.  
개발자들은 보통 롤모델을 찾고 그들을 우상화하며 흉내내면서 천재로 비춰지길 원한다.  
그래서 항상 완벽한 결과물이 나올때 까지 숨기고 짜잔 하면서 작업물로 동료들에게 인정을 받으려 하는데  
구글에서 이것은 잘못되었다고 판단한다.

### 2.2 홀로 일하는 것의 트레이드 오프

오롯이 홀로 일하는 것은 실패의 위험성을 불필요하게 키우는 것이라고 판단하기 때문이다.  
함께 일한다는 것은 빠르게 공유된다는 것이고 빠르게 공유되면서 프로젝트의 버스지수를 높이고  
이미 그 경험을 한 개발자로부터 배워 불필요한 시간이 낭비되는 것을 막을 수 있다.  
또 빠른 공유로 문제점을 조기에 파악하고 쉽게 원점회귀할 수 있다.

> p79, 다른사람이 아이디어를 훔친다거나 여러분이 똑똑하지 않다고 생각하는 게 두렵더라도,  
> 잘못된 일에 여러분의 천금 같은 시간을 낭비할 가능성을 더 걱정해야합니다.

### 2.3 사회적 관계의 중요성

그러나 공유하고 피드백할 때 팀원들의 '겸손', '존중', '신뢰'의 태도가 전제되어야한다.  
예측 가능한 컴파일러와 씨름하는 것이 쉬운데 굳이 왜 사회적인 문제들로 골치를 썩어야 하는가 ?  
개발만 잘하면 되는 것 아닌가? 라는 의구심이 생길 수 있다.  
그러나 더 가까워지려는 노력이 언젠가 주변 팀원들이 더 잘되도록 챙겨주게 되었던 사례를 보면  
"사회적 관계"의 힘을 무시하면 안된다.

### 2.4 겸손 존중 신뢰를 실천하기 위해서

- 먼저, 자존심을 버려야한다.
    
    - 모든 것을 다 아는 듯이 행동하지 말고 항상 첨언하고 싶어하는 것을 참아야한다.
        
    - 자존심은 다양한 모습으로 나타나는데 이런 자존심은 자신의 생산성을 떨어트린다.
        
        - **Wow!** **항상 편하게 입고다니는 존 터키는 신뢰도를 쌓기 위해 오랜 시간을 기다려야 했다. "내 식대로 하겠어"라며 자신만의 방식으로 자존심을 지키려고 고집하면 경력 내내 소소한 비용을 꾸준히 지불해야 한**다.
            
- 비평하고 비평받는 법 배우기
    
    - 비평하는 사람은 상대방을 진심으로 생각하고 상대방의 업무가 개선되길 바라야하는 마음에서 시작해야한다. 누군가를 진정으로 존중한다면, 재치있는 어휘또한 골라서 사용하게 될 것이다. (물론 연습이 많이 필요하지만)
        
    - **Wow!** **비평을 수용하는 사람은 상대방이 나와 프로젝트를 진심으로 생각하며, 나를 어리석다고 말하는 것이 아니라고 믿어야한다. 또, "나는 내 코드가 아니다"를 외치자. Wow!** **내 자존감과 내 코드를 동일시하지 말자**
        

### 2.5 결론

- 고립되어 일할 때의 트레이오프에 유의하자
    
- 대인 관계 충돌 때문에 낭비한 시간이 얼마나 많을지 생각하자. 다른 사람을 이해하는 시간을 조금만 쓴다면 생산성을 크게 높일 수 있다.
    
- 내가 선호하는 방식만큼 남이 선호하는 방식도 알아야한다.
    

## **Chapter 3. 지식 공유 ***

지식을 공유하는 문화는 조직의 성장을 좌우한다.

### 3.1 지식 공유를 쉽게하기 위한 규칙

지식 공유를 방해하는 가장 큰 요소는 "심리적 안전 부족"이다.  
자신의 질문이 오랫동안 남아있을 것에 대한 두려움이 가장 큰데, 초심자들이 쉽게 질문할 수 있는 환경을 구축해야 한다. 책에서는 심리적 안전을 위한 규칙을 적어뒀다.

- 모르는 것에 대해 놀람 금지 : 구성원들이 모른다는 사실을 인정하기를 두려워하지 않도록
    
- 음... 실제로는 금지 : 지나칠 정도로 세세허가 고쳐주는 행위 금지
    
- 뒷좌석 운전 금지 : 적절한 발언권 없이 끼어들어 의견 제시 금지
    

### 3.2 나부터 발전하기

지식 공유는 내 지식에서 부터 출발해야한다. 항상 무언가 배울 것이 있음을 인식하는 것이 매우 중요하다.  
**Wow!** **'너무 기초적'인 질문이라는 것, 혼자 극복해내고 싶다는 것, 도움을 청하기 전에 최대한 노력해보는 것이라는 생각에 막혔을 때 질문하지 않는 것이 초심자가 저지르는 가장 큰 실수다.**

인간은 언제나 아는 것보다 배워야 할 것이 많기 때문에  
이게 뭔지 모르겠는데 설명해주시겠어요? 라는 질문하는 것을 두려워 하지 말자.  
**Wow!** **또한, 상급자라면 모든걸 알아야 한다는 인식또한 없어야 한다.**

**Wow!** **책에서는 무엇인가를 배울 때, 기존 설계에 대한 맥락이해를 추천하고 있다.**  
**Wow!** **기존 설게와 구현의 이유를 먼저 이해하는 것 또한 배움이다.**  
**Wow!** **이것을 토대로 기존 설계의 부족한 부분을 명확하게 판단할 수 있고, 개선해나가며 새로운 배움 또한 얻을 수 있다.**  
**Wow!** **너무 성급하게 '이건 잘못됐어'라고 결론 짓지 말자.**

### 3.3 코드도 지식이다.

코드도 지식이라는 사실을 인지하면 코드 가독성과 명확성에 간접적으로 영향을 줄 때가 많다.  
코드 리뷰는 코드 작성자와 리뷰어 모두에게 배움의 기회를 준다.

## **Chapter 4. 공정 사회를 위한 엔지니어링 (skip….)**

다양성 존중 ?

## **Chapter 7. 엔지니어링 생산성 측정하기 (skip…)**

일단 스킵

## **Chapter 8. 스타일 가이드와 규칙 ***

규칙은 법이기에 꼭 따라야만한다. 개발자의 자유도를 제한하면서까지 규칙이 필요한 이유는 무엇일까?  
규칙이 있으면, 개발자들은 "어떻게" 표현할지에 대한 고민은 내려놓고 "무엇을" 포함하지?에 대해 집중적으로 고민할 수 있게된다. 이런 규칙들이 코드베이스에 일관되게 적용되어 있다면, 팀과 팀을 이동할 때 온보딩 시간을 줄일 수 있으며 사소한 논의로 시간을 낭비하지 않을 수 있다.

### 8.1 구글의 스타일 가이드 - 규칙

- 코드를 읽는 사람을 기준으로 정해진다.
    
    - 작성자가 번거롭더라도 코드의 라이프사이클을 고려했을 때, 코드는 작성보다 읽히는 시간이 더 크기 때문이다.
        
- 일관성을 최우선으로 한다.
    
- 규칙의 양을 최소화하여 규칙 자체를 배우는데 시간이 낭비되지 않도록하며, 수 많은 규칙은 지키기도 어렵다
    
- 오류가 나기 쉽거나 예상치 못한 동작을 유발하는 구조를 피하는 규칙을 둔다.
    
    - 신규 기능이라면 구성원 모두에게 전파되기 전에는 사용을 금지하거나
        
    - 고급 기능이지만 동작을 제대로 이해해야만 쓸 수 있는 기능이라면 사용을 금지하고 있다.
        
- 실용성을 고려하여 예외를 허용한다.
    
    - **Wow!** 그러나 예외를 허용하는데에는 근거가 있어야한다.
        

### 8.2 규칙을 수정하기 위해

규칙이 존재한다고 해서 새로운 방식을 배척하면 안된다.

- **Wow!** 구글 스타일 가이드에는 **고려사항, 결정 과정에서 중요하게 생각한 장점과 단점, 최종 결론에 다다른 근거**들이 서술되어 있다. 이렇게 상세하게 문서화되어 있어 규칙을 변경해야 할 때가 언제인지를 알기 쉽다.
    
- **Wow!** 규칙을 수정해야된다고 판단이 든다면, 현재 코드베이스 기준으로 실제 사례의 문제점을 명시하고  
    **새로운 해법과 해결된 상태를 제시해야한다.**
    
- 이렇게 논의가 시작되면, 다수결이 아닌 모두의 합의로 수정이 적용되는데, 이때 실제 규칙 수정으로 코드베이스에 수정이 들어갈 리소스 등 많은 것들을 고려하게 된다.
    

### 8.3 규칙을 지키기 위한 도구들

가능한 규칙들이 자동으로 적용되도록 만들어야 규칙 지키기가 쉬워진다.

- 구글은 규칙 위반사항과 어떻게 고쳐야하는지 제시해주는 코드분석기를 도입하고, 워크플로우에 자동으로 연동되도록 만들었다.
    
- 린트, 프리티어 등을 활용하여 자동으로 스타일 가이드를 지키도록 만들고, 프리커밋 등을 이용하여 레포지토리에 올라가기 전에 모든 개발자가 검사기를 이용하도록 강제한다.
    

## **Chapter 9. 코드 리뷰 ***

### 9.1 구글의 코드리뷰 프로세스

1. 코드를 변경한다.
    
2. 자동 리뷰의견을 받거나 스스로 리뷰 먼저 진행한다.
    
3. 리뷰어들에게 요청을 보내고 리뷰어들은 리뷰한다.
    
4. 리뷰를 반영한다
    
5. 머지한다.
    

### 9.2 코드는 부채다

코드는 그 자체로 부채이며 어느 순간 누군가가 유지보수해야 할 대상임을 잊으면 안된다.  
특히 신규 코드는 시간이 지날 수록 부채를 가중시키는 요소이기 때문에  
신규 코드를 만들기 전에 항상 기존 코드가 있는지 체크해야한다.  
코드 전체를 새로 짜는 일은 흔치 않아서 '밑바닥부터 만들고 있다면 분명 잘못하고 있는것이다.

### 9.3 구글의 코드리뷰

- **Wow!** **코드 정확성 평가**
    
    - 코드가 의도대로 이루어졌는데 평가한다
        
    - 해당 변경에 대한 테스트가 갖춰졌는지 평가한다.
        
    - 더 나은 해결책(컨벤션, 성능)이 있는 것이 아니라면, **Wow!** **작성자가 선택한 방식을 존중한다.**
        
        - **설계에 대한 변경 리뷰는 코드리뷰에 있으면 안된다 - 설계 리뷰에 했어야 한다.**
            
- **Wow!** **코드 이해용이성 평가**
    
    - 읽는 사람을 위한 코드가 작성되어야 한다.
        
    - 읽는 사람을 위해 코드 변경점이 적어야한다.
        
        - PR의 첫 문항에는 변경사항에 대한 친절한 설명이 존재해야한다.
            
        - 큰 변경사항은 리뷰어가 거절할 권리가 있다.
            
    - 코드가 잘 이해되지 않는다면, **고객은 항상 옳다라는 관점에서 질문을 던져야한다.**
        
- **Wow!** **코드 일관성(가독성) 평가**
    
    - 언어 모범 사례들을 잘 따랐는가에 대한 평가
        
    - 컨벤션을 따뤘는가에 대한 평가
        
    - 필요이상으로 복잡하지 않은가에 대한 평가
        
- 리뷰는 가능한 신속하고 자동화되어 있어야 한다.
    
    - 구글은 24시간 내에 리뷰가 완료될 것이라고 믿는다.
        
    - 테스트, 린터, 포맷터를 프리서브밋 과정에 포함해서, 리뷰어가 로직만 신경쓸 수 있도록 한다.
        

### 9.4 구글의 코드리뷰 유형

- **그린필드 코드 리뷰 : feat 브랜치**
    
    - 완전히 새로운 코드 대상으로 하는 리뷰를 말한다.
        
    - **Wow!** 이때의 기준은, 코드가 오랜시간 존속될 수 있는가를 기준으로 평가한다.
        
    - 물론 일시적인 기능인지 유지되는 기능인지 먼저 판단해야겠지
        
- **동작 변경, 개선, 최적화 : refactor 브랜치**
    
    - **Wow!** 가장 바람직한 변경은 "삭제"임을 기준으로 평가한다.
        
    - 변경된 동작에 맞게 테스트도 함께 수정되어야 함을 평가한다.
        
    - 기존 테스트들이 모두 통과했는지 평가한다.
        
    - **Wow!** 성능 개선이라면 벤치마크 결과를 리뷰어에게 제시했는지 평가해야한다.
        

## **Chapter 10. 문서자료 ***

문서자료가 주는 혜택은 주로 후임자에게 돌아가므로 작성자에게는 즉각적인 이득이 없는 경우가 많기 때문에, 모두 문서 개선에 더 힘써야 된다는 사실은 알지만, 핵심 이점이 없어 진행되지 않는 경우가 많다.  
그러나 문서를 작성하는 사람에게도 설계를 가다듬는데 도움을 주고, 유지보수를 위한 로드맵과 과거 이력이 남는다는 이점, 코드를 더 전문적이고 매력적으로 보이게 만든다는 이점을 주기도 합니다.

### 10.1 **Wow!** 구글 문서 리뷰

- 정확성을 기준으로 평가한다.
    
- 명확성을 기준으로 도메인을 잘 모르는 사람이 봐도 이해가 가능한지 명확한지 평가한다.
    
- 일관성을 기준으로 다른 문서들과 동일한 포맷을 갖추고 있는지 평가한다.
    

### 10.2 결론

문서자료는 나를 위해 작성하기보다  
읽는 사람을 기준으로 정확성, 명확성, 일관성을 지키며 작성해야된다.  
이런 문서화는 조직의 미래에 투자하는 것이다.

## **Chapter 11. 테스트 개요 ***

자동테스트는 빠른 시간에 버그를 잡는 것에 이점을 갖지만,  
빠르게 변화할 수 있는 환경을 제공해 준다는 큰 이점 또한 가지고 있다.  
자동테스트를 구축한 팀은 시장에 맞게 빠르게 기능을 배포할 수 있게 된다.

### 11.1 테스트의 장점

- **디버깅 감소**
    
    - 처음 테스트를 작성하는 것은 리소스를 잡아먹는 일이지만, 코드는 작성되는 시간보다 읽히고 수정되는 시간이 수백배 크다는 점에서, 코드가 살이있는 내내 값비싼 결함을 예방해주고 짜증나는 디버깅에서 해방시켜주는 혜택을 준다
        
- **자신있게 변경**
    
    - 좋은 테스트로 무장한 팀은 자신감을 가지고 변경을 리뷰하고 수용할 수 있다.
        
    - 특히, 행위가 달라지지 않는 최적화, 리팩토링은 기존 테스트를 수정할 필요조차 없어진다.
        
- **더 나은 문서자료**
    
    - 문서는 보통 최신의 코드를 대변하지 못하는 경우가 많다. 그렇기 때문에 코드가 특정 상황에 어떻게 동작하는지 알고 싶다면 테스트를 수행해보기만 하면 되기 때문에 더 나은 문서자료가 될 수 있다.
        
- **더 단순한 리뷰**
    
    - 구글에서는 프리커밋 테스트를 수행하기 때문에, 리뷰어들은 변경사항이 기존 기능을 제대로 수행하는가에 대해 의심하지 않고 리뷰할 수 있게 된다.
        
- **사려 깊은 설계**
    
    - 새로운 기능을 작성할 때 새로운 테스트를 작성해야한다.
        
    - 새로운 테스트가 복잡한 경우는 설계 자체가 잘못되었을 가능성이 있다. 이렇게 결합성이 높은 코드들에 대해 다시 한번 설계해볼 수 있는 시간을 갖게 된다.
        
- **고품질의 릴리스를 빠르게**
    
    - 좋은 자동테스트를 갖고 있는 팀은 불안에 떨지 않고 뉴 버전을 릴리즈 할 수 있게 된다.
        

테스트들이 수백개가 되는 테스트 스위트가 될텐데, 테스트 스위트가 수행되는 시간이 오래걸려 생산성을 떨어트리거나 변경사항 하나에도 수십개의 테스트 실패 결과를 뱉는다면 개발자들은 자연스럽게 테스트를 우회하는 방법을 찾게 될 것이다. 그러나 품질이 중요한 세상에서 테스트는 무시될 수는 없다. 구글은 테스트를 제대로 작성하는 것과 빠르게 수행되도록 하는 것을 엔지니어링 문화의 중심에 두고 있다.

### 11.2 테스트 설계하기

- **테스트 크기**
    
    - 테스트 크기는 코드 줄 수가 아니라 어떻게 동작하고, 무엇을 하고, 얼마나 많은 자원을 소비하는지로 평가한다. 구글은 최대한 작은 테스트를 유지하기를 권장한다.
        
    - 보통 인프라에 대변되는 것으로 읽혔는데, 이것이 프론트에서 쓰일 수 있는지 의문이 들어 상세한 내용 기재는 스킵
        
- **테스트 범위**
    
    - 테스트가 얼마나 많은 코드를 검증하느냐를 말한다.
        
    - (단위 테스트)좁은 범위 테스트 : 독립된 클래스나 메서드같이 가장 작은 로직을 검증하도록 설계한다.
        
    - (통합 테스트)중간 범위 테스트 : 적은 수의 컴포넌트들 사이의 상호작용을 검증하도록 설계한다.
        
    - (기능 테스트)넓은 범위 테스트 : 시스템의 서로 다른 부분들 사이에서의 상호작용을 검증하도록 설계한다.
        
- **비욘세 규칙**
    
    - 어떤 행위나 속성을 테스트해야 되는 질문에 대한 답으로 구글은 비욘세 규칙을 따른다.
        
    - 깨뜨려보고 싶은 모든것을 테스트 하라는 뜻이다.
        
    - 비욘세 규칙을 따라 미리 망가트려보고 이것에 대한 대응을 설계할 수도 있다.
        
- **Wow!** **코드 커버리지의 모순**
    
    - 코드 커버리지는 실제 코드수 대비 테스트에 호출된 코드 라인의 비율을 말한다.
        
    - 코드 커버리지가 목표가 되는 팀이 있는데, 코드 커버리지는 테스트 되지 않은 코드가 어디인지는 알 수 있는 용도에 불과하며 이것이 좋은 테스트라는 것을 대변할 수는 없다.
        
- **깨지기 쉬운 테스트**
    
    - 예상 결과를 너무 세세하게 작성하거나 복잡하게 작성되어 있으면, 작은 변화에도 수십개의 테스트 에러를 내뱉게된다. 이럴 때, 기능 변경을 작성하면 테스트 코드도 방대한 수정이 필요하므로 상수로 검증하는 등의 테스트코드는 작성하면 안된다.
        
- **Wow!** **수행시간이 긴 테스트**
    
    - sleep등 기다렸다 검사하기 전략을 쓰게되면 유휴시간이 몇 분 단위가 되는 것은 순식간이다. 테스트가 길어지면 오히려 생산성이 감소되고 개발자들은 테스트를 우회하게 되므로, 기다렸다 검사하기는 최소화해야한다.
        

## **Chapter 12. 단위 테스트 ***

테스트의 가장 큰 목적은 버그예방, 두번째 목적은 생산성 개선이다.  
구글에서는 생산성 개선을 위해 단위테스트를 많이 작성하고, 자주 실행하도록 만든다. (기능 생성,변경과 동시에 작성할 정도로 단위테스트는 쉬우니까) 구글의 개발자는 단위테스트를 자주 실행하는 대신 “**테스트 유지보수성**”에 대해 집착한다.

### **12.1 유지보수성에 좋지 않은 테스트 코드**

- **깨지기 쉬운** 테스트코드는 안된다.
    
    - 기능을 변경했고 문제는 없지만 오류를 뱉는 테스트코드들이 깨지기 쉬운 테스트코드다.
        
    - 보통, 어떤 한 구조나 형태를 반환할 것이라고 믿는 테스트 코드들이 보통 깨지기 쉽다.
        
    - 이런 테스트코드를 수정하는 시간까지 들어가야 된다.
        
- **불명확한** 테스트코드는 안된다.
    
    - 무엇이 잘못되어 실패했는지, 무엇을 증명하려했는지 불명확한 테스트코드들
        
- 깨지기 쉬운 테스트 코드나 불명확한 테스트코드는 애초에 체크인 되기 전에 걸러져야한다.
    

### **12.2 테스트 코드 변경 사례**

- **Wow!** **Case 1: 순수 리팩터링**
    
    - 최적화, 가독성 개선등의 작업은 기능의 input과 output이 달라지면 안된다.
        
    - 리팩터링을 했는데 기존 테스트코드를 변경해야 한다면 문제는 둘중에 하나다.
        
        - 리팩터링이 기능을 변경한 경우 - 이때는 리팩터링이 제대로 되지 않았거나, 사이드이펙트를 발생했다는 의미다. 이때는 테스트코드가 아니라 기능을 변경해야한다.
            
        - 테스트코드가 input과 output이 아닌 세부 로직에 지나치게 의존한 경우 - 이때는 테스트코드를 수정해 유지보수성 좋은 테스트코드로 변경해야한다.
            
- **Wow!** **Case 2: 새로운 기능 추가**
    
    - 새 기능을 작성할 때는 검증할 테스트를 새로 작성해야한다.
        
    - 만약 기존 테스트를 변경해야 한다면 새로운 기능이 사이드이펙트를 발생시켰거나,  
        테스트가 잘못되었음을 의미한다.
        
- **Wow!** **Case 3: 버그 수정**
    
    - 버그가 존재한다는 것은 기존 테스트 스위트에 빠진 검증이 존재한다는 것이다.
        
    - 테스트 코드를 추가한다.
        
- **Wow!** **Case 4: 행위 변경**
    
    - 기존 행위를 변경하는 breaking change가 발생한 경우, 기존 테스트 코드들도 변경해야한다.
        
    - 기존 테스트를 수정하는 경우는 오직 이런 대대적 변화가 일어날 때만 존재하는 것이 이상적이다.
        

### **12.3 유지보수성을 좋은 테스트 코드 작성 팁**

- **Wow! 공개 API** 이용하는 테스트
    
    - 내부 로직이나 함수가 아니라, **실제 유저 경험에서 자연스럽게 호출되는 외부로 노출된 흐름, 메소드, 이벤트로 테스트를 진행**해야 더 현실적이고 잘 깨지지 않게된다.
        
    - 명시된 케이스만 검증된다면 리팩터링 중 귀찮은 테스트 수정은 없게될 것
        
- **Wow!** 상호작용이 아니라 **상태를 테스트**
    
    - 기대한 대로 동작하는지 검증하는 방법에는 “상태 테스트”와 “상호작용 테스트”가 있다.
        
        - 상태 테스트는 메소드 호출 후 시스템의 상태들을 검증하는 것
            
        - 상호작용 테스트는 일련 동작을 잘 수행하는지 (메소드가 흐름대로 호출되는지)를 검증하는 것
            
        - 상호작용 테스트가 더 깨지기 쉽다.
            
    - **어떤 함수가 호출되었는지보다, 호출된 이후 변경된 값을 검증하는 것을 추천한다.**
        
- **명확한 테스트**를 작성하기
    
    - 명확한 테스트는 존재 이유와 실패 원인을 엔지니어가 바로 알아차릴 수 있는 테스트를 의미한다.
        
        - 실패가 발생했을 때 원인은 시스템에 문제가 있는 경우거나 테스트 자체의 결함이 있는 경우를 의미한다.
            
    - **테스트 자체도 읽는사람을 기준으로 작성하자**
        
- **Wow!** 메서드가 아니라 **행위를 테스트하자 ***
    
    - 보통 엔지니어들은 본능적으로 테스트 구조를, 대상 코드의 구조나 흐름에 일치시키려는 경우가 있는데, 실제로 동작되는 메서드는 여러 역할을 수행하기도 한다. **만약 메서드 흐름처럼 테스트를 구성하면 테스트 흐름이나 결과가 불명확해지는 경우가 많다.**
        
    - **특정 상태에서(Given), 특정한 입력을 받았을 때(When), 어떤 출력이 나오는가(Then)을 기준으로 테스트를 작성해야 한다. 실제로 Given, When, Then을 주석으로 작성하고 테스트를 작성하자.**
        
    - **행위 주도 테스트는 자연어에 가까워 읽히기 쉽고, 테스트가 특정 경우만을 수행하기 때문에 간결하며, 무엇을 검증하려는지 바로 이해하기 쉽다.**
        
        - 만약 여러 흐름을 거치면서 단계별로 상태를 검증해야 된다면 And 절을 추가하자  
            Given - When - And - Then - When - And - Then의 순서로 작성하자
            
- 테스트 **이름은 간결**하게 작성한다
    
    - 기능을 모두 함수에 녹이려고하지 말자
        
- **Wow!** 테스트에 **논리를 넣지 말자**
    
    - **연산자, 반복문, 조건문**을 넣는 순간 추론하기 어려워진다.
        
    - 뿐만 아니라, 테스트의 연산이 잘못되었을 때 - 코드에서도 동일한 실수를 반복한다면 버그를 발견하기 어렵다
        
- **Wow!** **실패 메세지를 정확하게 작성하자**
    
    - 너무 간단하게 작성하면 테스트를 실패해도 뭐 때문에 실패했는지 알 수가 없다.
        
    - **어떤 상태를 기대했는데, 이런 결과가 나와서 실패했음**을 명확히하자.
        
- **Wow!** **공유 값 - 도우미 메서드**
    
    - 여러 테스트를 수행하기 위해 공유값을 설정할 때가 있는데, 보통 이름을 간편하게 짓거나 최상단에 변수들을 설정한다. 이때 각각의 테스트문에서 실제 어떤 값을 세팅했는지 찾기 위해 스크롤도 해야하며, 실제 이 테스트에는 왜 이런 초기값을 세팅했는지 - 더불어 이 값을 세팅해서 무엇을 검증하려 했는지도 불분명해진다.
        
    - **따라서 어떤 상태를 설정하려면 메소드를 통해 값을 반환하는 형태 (도우미 메서드)를 사용하자.**
        

## **Chapter 13. 테스트 대역 (skip…)**

## **Chapter 14. 더 큰 테스트 (skip…)**

## **Chapter 15. 폐기**

코드는 부채이며 언젠가는 폐기되어야 할 대상이다.  
그래서 구글은 시스템을 설계할 때 다음과 같은 고려사항이 존재한다.

- 현재 설계하는 시스템에서 다른 시스템으로 이주할 때 편한가?
    
- 점진적 이주를 한다면 어떻게 진행할 수 있을까?
    

폐기를 진행하는 것과 각 현장에서 부분적으로 리팩터링하여 개선을 진행하는 것의 편익을 고려하여  
폐기를 결정해야한다. 만약 폐기를 진행한다면 마일스톤과 함께 기존시스템과 현재시스템의 연동까지 고려해야한다.

# **느낀점, 적용할점**

---

- p234. 작성자는 초기패치를 사용하여 자동 리뷰 의견을 받거나 스스로 리뷰를 해봅니다.
    
    - 스스로 리뷰해보자 내가 지금까지 받았던 리뷰들을 정리하고 이걸 지피티한테 학습해보고 다시 돌려보자
        
    - 동료들이 피드백한 내용을 낭비하지말자
        
- p.100 엔지니어들은 너무 성급하게 '이건 잘못됐어'라고 결론 짓는 경향이 강하다. 무언가를 옮기거나 바꾸려면  
    p.235. 코드 전체를 새로 짜는 일은 흔치 않아서 '밑바닥부터 만들고 있다면 분명 잘못하고 있는거야'
    
    - 중복을 체킹하자
        
    - 그게 왜 그자리에 있는지부터 이해하자. 그것 또한 배움이고, 부족한 것을 채워나가면 더 큰 배움이 될 것 같다.
        
- 코드리뷰 유형, 가독성-일관성-이해용이성 기준으로 리뷰해봐야겠다.
    
- 코드는 자산이 아니고 부채다. 또 내 코드는 나의 자존감과는 다른 친구다
    
    - 동료들의 피드백을 나의 험담이 아니라 성장의 발판으로 삼자
        
    - 동료들의 피드백을 제대로 받기 위해 PR을 열심히 작성하고 고민한 내용도 함께 작성하자
        
- 테스트코드의 중요성을 알게되었다.
    
    - 진짜 테스트코드 제대로 작성해보자. 제대로 검증하는 테스트코드란 무엇인지 알아가보자
        

# **논의할점**

---

- p.106 구글러들이 자신의 제안을 검토할 문서자료 소유자를 찾도록 도와주는 도구인 g3doc이 있다.
    
    - 쉽게 검색하는 도구가 아니라, 우리도 문서자료를 리뷰하는 방식을 두는 것은 어떨까?  
        예를 들면, 컨플루언스 말고 readme 형태로 git 레포에 PR하는 형태
        
    - 더 읽기 쉬운 문서, 파편화되는 것을 방지할 수 있지 않을까 ??
        
- p242 이해용이성에 대한 코드리뷰
    
    - 이 코드가 왜 존재하나요를 넘어서, 로직 자체에 대한 이해 용이성을 논의해본 적은 없는 것 같기도.. ?
        
    - 그것을 이해할 필요가 있을까 ? 이해하려고 한다면 어떻게 질문해야할까
        
        - 전제되어야 할 것은 작은 PR 단위가 아닐까 궁금해졌다.
            
- p282. 테스트 코드 작성 논의
    
    - 확실히 이 책을 읽고 테스트코드의 필요성을 느꼈다.
        
    - 우리는 유틸함수와 같이 공용부분 테스트코드 작성하는 걸로 결정했지만, 실제로 우리에게 힘든 것은 도메인 영역에서 리팩터링이나 추가 기능 개발이라는 생각이 든다. 테스트코드가 있다면 더 안심하고 작업을 진행할 수 있지 않을까 한다.
        
    - 근데 UI 영역의 테스트는 익숙하지 않아서 번거로웠던 것 같은데, 우리도 이제 테스트코드가 필요할지 한다면 지금처럼 유틸함수 위주로 테스트코드 작성하는 것이 좋을지 논의해보고싶다.