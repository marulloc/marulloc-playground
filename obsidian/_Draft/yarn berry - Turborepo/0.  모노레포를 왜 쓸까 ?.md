

1. 새 프로젝트 생성은 비용이 크다 
2. 프로젝트간 코드 공유가 위해선 라이브러리를 위한 또 하나의 레포가 필요하다 - 레포마다 코드 공유 어렵다 
3. 히스토리 관리 어려움 
4. 제각각인 툴링으로 개발자 경험이 일관적이지 않다. 



기능
- 로컬 캐싱 -> 같은작업 두번다시 
- 로컬 태스크 오케스트레이션 -> 같은머신에서 여러 태스크의 순서와 병렬처리 여부를 결정 할 수 있다.
- 원격캐싱 -> 한번 작업한 것은 캐싱되고 이게 공유되어서, 원격머신에도 캐싱이 된다.
- 변경된 프로젝트 감지 -> 어떤 프로젝트를 감지하면 , 변경된 부분만 특정 작업을 수행한다. 


- 코드 공유
- 스캐폴딩등 코드 생성 쉽게 해준다,
- 프로젝트간 의존성 관계를 제한할 수 도 있고 


### 모노레포 기술적 요구사항
----
https://www.youtube.com/watch?v=Ix9gxqKOatY
1. 의존성관리
	1. 유렁의존성 - npm yarn classinc 은 중복되는 라이브러리 설치를 피하고자 호이스팅 기법을 사용하는데, 이로 인해 한 모듈에서 의존성으로 명시하지 않은 것들이 로드되게 된다.
		1. 이런 노드모듈스 문제를 해결하기 위해 yarn berry + pnp를 사용한다. 
		2. 의존성으로 설치된 모듈들은 호이스팅되지 않고 yarn cache 폴더에 압축파일 형태로 저장된다.
		3. 이런 의존성의 관계들은 cjs 파일을 통해 엄격하게 관리된다. 즉, 명시되지 않은 의존성은 사용 될 수없고 유령의존성 문제가 발생하지 않게 된다.
		4. 추가적으로 zero-install
		5. 빠른 의존성
		- Peer Dependency
			- 상속된 의존성, 패키지 자체가 아니라 패키지에서 사용하는 곳에서 정의하는 것이다.
			- 내 프로젝트에서 Loadsh를 사용하고 있고 , 추가로 A라는 패키지를 사용할 때
			- A라는 패키지도 Lodash를 사용하고 있으면, 내 프로젝트에는 Lodash가 두개 포함된다.
			- 아아아ㅏ 이해안된다 ---- peer dependency 문제

			- Peer Dependency는 전파된다.
				- >>>
			- 런타임에서 에러를 발생시킬 수 도 있다. 
			- Peer Dependency는 잘 사용하면 같은 패키지에 번들을 하나만 추가 할 수 도 있다. 그래서 싱글턴으로 해당 패키지를 사용하는 경우에는 너무 좋은 기능이다
1. 버전관리
	1. 노드 생태계에선 Semver라고 하는 일반적인 버저닝을 따른다 (시맨틱 버저닝)
		1. breaking change는 major version
		2. api 인터페이스가 변경되진 않지만, 새로운 기능이 추가될때 minor version
		3. 버그수정등 패치작업이 발생하면 paches 를 변경한다.
	2. 사용하는 곳에서는 오직 semver에만 의존해서 라이브러리를 사용하게 된다
		1. 그래서 라이버리리에서는 버져닝을 엄격하게 해야한다.
2. 코드 품질 관리
	1. RFC와 
3. Git 전략 
	- 