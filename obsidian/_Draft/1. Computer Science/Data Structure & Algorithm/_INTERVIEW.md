
### 1. Array (배열)

- **선형 검색 (Linear Search)**: 배열의 각 요소를 차례대로 검색하여 원하는 값을 찾는 방법.
- **이진 검색 (Binary Search)**: 정렬된 배열에서 중간값을 기준으로 분할하여 원하는 값을 더 빠르게 찾는 방법.
- **정렬알고리즘** : 
> **UI 컴포넌트의 목록 렌더링**: 게시글 목록, 댓글 목록 등을 렌더링할 때 사용. 배열에 저장된 데이터를 순회하며 각 항목을 화면에 표시합니다.



### 2. List (리스트)

- **삽입 및 삭제 (Insertion & Deletion)**: 특정 위치에 요소를 추가하거나 제거하는 연산.
- **연결 리스트 순회 (Traversal)**: 연결 리스트의 모든 요소를 방문하는 과정.


> **동적 콘텐츠의 관리**: 사용자 인터페이스에서 동적으로 추가되거나 제거되는 요소들(예: 무한 스크롤에서 불러오는 항목들)의 관리에 사용될 수 있습니다.


### 3. Stack (스택)

- **후입선출 (LIFO) 연산**: 가장 마지막에 삽입된 요소가 가장 먼저 삭제되는 특성을 이용한 연산.
- **괄호 검사 (Parentheses Checking)**: 괄호의 짝이 올바르게 닫혀 있는지 확인하는 알고리즘.

> **뒤로 가기 기능 구현**: 사용자가 방문한 페이지나 상태의 이력을 스택에 저장하고, 뒤로 가기 버튼을 클릭할 때마다 스택에서 최근 항목을 꺼내 이전 상태로 돌아가는 데 사용됩니다.


### 4. Queue (큐)

- **선입선출 (FIFO) 연산**: 가장 먼저 삽입된 요소가 가장 먼저 삭제되는 특성을 이용한 연산.
- **순환 큐 (Circular Queue)**: 배열을 사용하여 큐의 용량을 효율적으로 사용하는 방법.

> **비동기 작업의 순차 처리**: 여러 비동기 요청(예: API 호출)을 큐에 넣고, 하나씩 순차적으로 처리하여 순서를 보장해야 할 때 사용됩니다.


### 5. Deque (덱)

- **양방향 삽입 및 삭제**: 덱의 양쪽 끝에서 요소를 삽입하거나 삭제할 수 있는 연산.

> **양방향 슬라이드 쇼**: 사용자가 이전 또는 다음 이미지로 넘길 수 있는 이미지 슬라이더에 사용. 앞뒤로 추가하거나 제거하는 데 유용합니다.


### 6. Heap (힙 = 우선순위 큐를 위해 사용되는 자료구조)
https://chamdom.blog/heap-using-js/
**힙(heap)**은 완전 이진 트리의 일종으로 `우선순위 큐`를 위하여 만들어진 자료구조이다. 힙은 완전히 정렬된 것은 아니지만 전혀 정렬 되지 않은 상태도 아닌 반정렬 상태(느슨한 정렬 상태)를 유지한다.

- **힙 정렬 (Heap Sort)**: 최대 힙 또는 최소 힙의 특성을 이용하여 배열을 정렬하는 알고리즘.
- **우선순위 큐 (Priority Queue)**: 힙을 이용하여 구현되며, 우선순위가 높은 요소를 먼저 처리하는 자료구조.

> **데이터 스트리밍에서의 최대/최소 값 관리**: 실시간 데이터(예: 주식 가격)의 최대값 또는 최소값을 빠르게 찾아 UI에 표시할 때 사용할 수 있습니다.


### 7. Hash Table (해시 테이블)

- **해시 함수 (Hash Function)**: 키를 해시 테이블에 저장된 인덱스로 변환하는 함수.
- **충돌 해결 기법 (Collision Resolution Techniques)**: 체이닝(Chaining), 오픈 어드레싱(Open Addressing) 등의 방법으로 해시 충돌을 해결.

>**데이터 캐싱 및 빠른 검색**: 사용자 인터페이스의 상태 관리 또는 컴포넌트 간의 데이터 전달 시 빠른 검색을 위해 사용. 예를 들어, 사용자 ID별로 사용자 정보를 저장하고 빠르게 액세스할 수 있습니다.


- Hash Map
	- 
> # Javascript 에서 Object를 해시맵처럼 사용하지 마세요
> Map은 설계단계부터 데이터의 추가와 제거에 최적화 되어 있기 때문에 성능에 있어서 매우 유리합니다.
> 맥북프로에서 천만개의 데이터 셋을 가지고 테스트 했을 때 Object는 1.6초의 처리시간이 필요했고 Map은 1ms 이하의 처리시간을 보였습니다.
### 8. Tree (트리)

- **이진 탐색 트리 (Binary Search Tree)**: 트리의 각 노드에서 왼쪽 자식은 노드보다 작고, 오른쪽 자식은 노드보다 큰 값을 가지는 특성을 가진 트리 구조.
- **트리 순회 (Tree Traversal)**: 전위, 중위, 후위 및 레벨 순서 순회 등 트리의 노드를 체계적으로 방문하는 방법.

> - **DOM의 구조화**: 웹 페이지의 문서 객체 모델(DOM)은 트리 구조로 되어 있으며, 이를 통해 요소들의 계층적 관계를 관리합니다.
> - **계층적 데이터 표시**: 파일 시스템 브라우저, 댓글의 스레드 등을 표현할 때 사용됩니다.



### 9. Graph (그래프)

- **깊이 우선 탐색 (Depth-First Search, DFS)**: 그래프의 깊이를 우선적으로 탐색하여 모든 노드를 방문하는 방법.
- **너비 우선 탐색 (Breadth-First Search, BFS)**: 그래프의 너비를 우선적으로 탐색하여 모든 노드를 방문하는 방법.
- **다익스트라 알고리즘 (Dijkstra's Algorithm)**: 가중치가 있는 그래프에서 한 노드에서 다른 노드까지의 최단 경로를 찾는 알고리즘.
- **크루스칼 알고리즘 (Kruskal's Algorithm)**: 그래프의 모든 노드를 최소 비용으로 연결하는 최소 신장 트리를 찾는 알고리즘.
- **위상정렬** : 방향이 있는 비순환 그래프(DAG, Directed Acyclic Graph)의 모든 노드를 "선행 순서"에 따라 나열하는 알고리즘입니다.

> **소셜 네트워크, 추천 시스템**: 사용자 간의 관계나 상품 간의 관계를 표현할 때 사용. 예를 들어, 친구 추천 기능을 구현할 때 활용될 수 있습니다.



# 1. Array vs List 
배열과 리스트의 차이는 데이터 저장 방식, 접근 속도, 크기 변경의 유연성에서 구분

**Array (배열)**:
- 배열은 같은 타입의 데이터를 메모리의 연속적인 공간에 저장하는 자료구조입니다.
- 배열의 크기는 생성 시 정해지며, 대부분의 프로그래밍 언어에서는 배열의 크기를 동적으로 변경할 수 없습니다.
- 요소에 접근할 때 인덱스를 사용하여 빠른 접근이 가능합니다(O(1) 접근 시간).
- 삽입, 삭제 작업은 비효율적일 수 있습니다. 특히, 배열의 중간에 요소를 삽입하거나 삭제하려면 다른 요소들을 이동시켜야 합니다.

**List (리스트)**:

- 리스트는 데이터의 집합을 나타내는 자료구조로, 배열과 다르게 메모리 내에서 연속적인 공간을 차지하지 않을 수 있습니다.
- 대표적으로 연결 리스트가 있으며, 연결 리스트는 노드들이 포인터를 통해 서로 연결된 형태입니다.
- 리스트는 동적으로 크기가 변할 수 있으며, 요소의 삽입과 삭제가 유연합니다. 새로운 요소를 추가하거나 기존 요소를 삭제할 때 다른 요소들을 이동할 필요가 없습니다.
- 요소에 접근할 때는 시작 노드부터 순차적으로 탐색해야 하므로, 배열에 비해 접근 속도가 느릴 수 있습니다(O(n) 접근 시간).

> Javascript의 `[ ]` 는 뭘까
> , JavaScript의 `Array`는 고정된 크기를 가진 전통적인 배열보다는, 크기를 동적으로 변경할 수 있는 리스트와 유사한 동적 배열의 특성을 더 많이 가지고 있습니다.
 



# 3. Graph vs Tree
트리와 그래프의 주요 차이는 구조와 사이클의 유무, 연결성의 차이에서 나타나며,

**Tree (트리)**:

- 트리는 계층적인 데이터 구조로, 노드 간에 1:1의 부모-자식 관계를 갖습니다.
- 트리에는 사이클(순환 구조)이 존재하지 않습니다. 즉, 어떤 노드에서 출발해도 같은 노드로 돌아오는 경로가 없습니다.
- 모든 트리는 연결되어 있으며, 트리 내의 어떤 두 노드 간에도 정확히 하나의 경로만 존재합니다.
- 트리는 하나의 루트 노드를 가지며, 이 루트 노드에서 시작하여 각 노드에 접근할 수 있습니다.
- 예시: 파일 시스템, DOM 트리, 이진 검색 트리 등.

**Graph (그래프)**:

- 그래프는 노드(정점)와 이들을 연결하는 엣지(간선)의 집합으로 구성된 비계층적 데이터 구조입니다.
- 그래프는 사이클을 포함할 수 있으며, 노드 간에 다양한 관계(1:1, 1:N, N:N 등)를 나타낼 수 있습니다.
- 그래프는 연결되어 있지 않을 수 있습니다. 즉, 서로 독립적인 여러 그래프 조각(서브그래프)으로 구성될 수 있습니다.
- 방향 그래프(Directed Graph)와 무방향 그래프(Undirected Graph)가 있으며, 간선에 방향성이 있거나 없을 수 있습니다.
- 예시: 소셜 네트워크, 도로망, 웹 페이지의 하이퍼링크 구조 등.