> `웹`상에서 데이터를 주고 받기 위한 **서버/클라이언트 모델**을 따르는 프로토콜이다.
> 애플리케이션 레벨의 프로토콜로 **TCP/IP위에서 작동**
>- Connection less : **서버에 연결하고, 요청해서 응답을 받으면 연결을 끊어버린다.**
>- State less : 연결을 끊어버리기 때문에, 클라이언트의 이전 상태를 알 수가 없다

1. **GET과 POST 요청의 차이점은 무엇인가요?**
    - GET은 데이터를 조회할 때 사용되며 URL에 데이터가 포함되어 전송되고, POST는 데이터를 서버로 제출할 때 사용되며 데이터가 HTTP 메시지 바디에 포함되어 전송됩니다.
2. **HTTP 메소드 중 PUT과 PATCH의 차이는 무엇인가요?**
    - PUT 메소드는 대상 리소스의 전체를 대체하는 데 사용되며, PATCH 메소드는 대상 리소스의 일부를 수정하는 데 사용됩니다.
3. 응답코드
	- **1XX (조건부 응답)** : 요청을 받았으며 작업을 계속한다.
	- **2XX (성공)** : 클라이언트가 요청한 동작을 수신하여 이해했고 승낙했으며 성공적으로 처리했음을 가리킨다.
	- **3XX (리다이렉션 완료)** : 클라이언트는 요청을 마치기 위해 추가 동작을 취해야 한다.
	- **4XX (요청 오류)** : 클라이언트에 오류가 있음을 나타낸다.
		- 401 인증 - 인증 안됨
		- 403 인가 - 접근 권한
	- **5XX (서버 오류)** : 서버가 유효한 요청을 명백하게 수행하지 못했음을 나타낸다.


# HTTP Method
---


# HTTP Cache
---
#### Response Header
1. **Cache-Control**: 캐시 제어 지시어를 지정합니다. 다양한 지시어를 포함할 수 있다.
	- `max-age=[seconds]` : 캐시가 유효한 시간 결정
		- max-age를 사용하면 서버에 아예 요청을 보내지 않기 때문에 
		- CDN의 캐시 버스팅 같이 어떤 일이 일어나도 브라우저의 캐시를 갱신해주기가 어렵다. 
		- 대신 시간이 만료되면 서버에게 재검증 요청을 보내게된다.
	- `no-cache` : "no-cache"는 캐시를 사용하지만 항상 서버에 재검증을 요청
		- 사실상 `max-age=0`과 동일한 동작을 하게 된다.
	- `no-store` : 캐시를 절대로 해선 안되는 리소스일 때 사용한다. 
		- 이 지시어를 사용하면 브라우저의 어느곳에서도 해당 리소스를 저장하지 않는다.
	- `private` or `public` 
		- CDN과 같은 중간 서버가 특정 리소스를 캐시할 수 있는지 여부를 지정
		- public은 모든 사람과 중간 서버가 캐시를 저장할 수 있음을 나타내고, 
		- private은 가장 끝의 사용자 브라우저만 캐시를 저장할 수 있음을 나타냅니다. 
		- max-age 값과 조합 `Cache-Control: public, max-age=86400` 같이 콤마로 연결
	- `s-maxage` 
		- 중간 서버에서만 적용되는 max-age 값을 설정하기 위해 s-maxage 값을 사용예를 들어, Cache-Control 값을 `s-maxage=31536000, max-age=0` 과 같이 설정하면
		- CDN에서는 1년동안 캐시되지만 브라우저에서는 매번 재검증 요청을 보내도록 설정
	- `must-revalidate` : 캐시된 콘텐츠의 유효기간이 지나면, 서버에게 콘텐츠의 유효성을 반드시 재확인하도록 요구

2. **Expires**: `max-age` **지시어** 대신 `Expires` 헤더를 사용하면 캐시가 만료되는 `절대시점`을 지정
	- 대신 Cache-Control 헤더가 존재하는경우 Expires는 무시될 수 있다.
3. **Last-Modified**: 리소스의 마지막 수정 날짜를 지정합니다. 
	- 이 헤더는 웹 서버가 리소스를 마지막으로 수정한 날짜를 클라이언트에게 알려줍니다.
	- `if-Modified-Since` 와 관련 
1. **ETag**: : "ETag"는 리소스의 특정 버전을 식별하는 데 사용되는 고유한 식별자
	- 클라이언트와 주고 받으면서 캐시를 갱신해야되는지 판단하는 하나의 지표가 된다.
	- `if-none-match` 와 관련

#### Request Header - 조건부 헤더
1. `If-Modified-Since`: 클라이언트가 가장 최근에 받은 리소스의 수정 날짜를 서버에 전달하는 용도
	- 리소스를 받았을 때, 서버가 전달해준 `Last-Modified` 헤더값을 가지고 있다가
	- `Expires`명시된 시점을 지났거나 `max-age` 지났을때 브라우저가 이 헤더를 담아서 재검증 요청
	- 만약 리소스가 변경되지 않았다면 304 Not Modiied 응답을 반환받게 되고 캐시된 것을 그대로 쓴다.
    
1. **`If-None-Match`**: 클라이언트가 가장 최근에 받은 리소스의 ETag 값을 서버에 전달하는 용도
	- 이전에 응답받은 헤더에 ETag가 있으면 브라우저는 ETag를 헤더에 담아서 재검증 요청
	- 서버는 이를 사용하여 리소스가 변경되었는지 확인하고, 
	- 변경되지 않았다면 304 Not Modified 응답을 반환, 브라우저는 캐시된 리소스를 그대로 쓰게 된다.

> 재검증 요청은 조건부헤더를 사용하게 된다.
> 데이터 전문을 받는 것이 아니라, 변경 여부만 물어보는 것이기 때문에 일반 요청보다 빠르다



 
# REST API
---
REST 란 ?
1. HTTP URI(Uniform Resource Identifier)를 통해 자원(Resource)을 명시하고,
2. HTTP Method(POST, GET, PUT, DELETE, PATCH 등)를 통해 해당 자원(URI)에 대한 CRUD Operation을 적용하여 API를 설계하는 것을 의미하는데

따라야 되는 규칙으론
- URI는 동사보다 명사를/ 소문자를
- 언더바대신 하이픈
- 행위를 URI에 명시하지 않는다.
- 마지막에 슬래시를 포함하지 않는다. 

특징
- Stateless - HTTP 의 Connectionless에 따라
- Cacheable - HTTP Cache Control 

장점
- HTTP 프로토콜 인프라를 그대로 사용해서 별도의 인프라를 구축할 필요가 없고
- API 메세지만 보더라도 의도하는 바를 쉽게 파악할 수 있다.
단점
- 서버가 정해준 방식대로 클라이언트에서 요청해야 된다. 
	- 이 단점때문에 오버페칭 언더페칭이 발생한다. 



https://khj93.tistory.com/entry/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-REST-API%EB%9E%80-REST-RESTful%EC%9D%B4%EB%9E%80

> REST API : REST 원칙을 따르는 API 로 규칙을 따라야 한다.
> RESTful API : REST API 설계 규칙을 따르는 시스템

> GraphQL : 오버페칭/언더페칭 문제 해결
> - 단일 엔드포인트만을 이용하여 처리하여 요청형식을 고민하지 않아도 된다
> - 클라이언트가 필요한 데이터들을 불러올 수 있어 오버페칭 언더페칭 문제를 해결한다.
> 
> - 대신 단일 엔드포인트여서 HTTP Caching 활용이 어렵다
> - 에러처리가 복잡하다. 성공한 데이터와 에러데이터가 같이 전송된다.


# HTTP 1.1/2.0/3.0
---

   - HTTP 2는 HTTP 1.1에 비해 여러 가지 성능 개선 사항을 제공합니다. 주요 차이점으로는 한 커넥션에서 여러 개의 요청과 응답을 동시에 처리할 수 있는 멀티플렉싱, 서버 푸시 기능, 헤더 압축 등이 있습니다.




# HTTP/HTTPS
---
- **HTTP(Hypertext Transfer Protocol)** 
  보안 기능이 없으며 텍스트 데이터를 암호화하지 않습니다.
  
- **HTTPS(Hypertext Transfer Protocol Secure)**: 
  HTTP의 보안 버전으로, SSL(Secure Sockets Layer) 또는 TLS(Transport Layer Security) 프로토콜을 사용하여 데이터를 암호화합니다. 따라서 데이터의 안전성을 보장하고 중간자 공격을 방지합니다.

##### [1-2] 그렇다면 SSL과 TLS가 뭐에요?
SSL(Secure Sockets Layer)과 TLS(Transport Layer Security)은 모두 네트워크 통신을 보호하기 위한 프로토콜입니다. 보통 데이터 통신의 보안을 강화하기 위해 사용됩니다.

- **SSL (Secure Sockets Layer)** - Application Layer에서 보안
	SSL은 최초로 보급된 보안 프로토콜로서, 데이터의 안전한 전송을 위해 개발되었습니다. 
	주로 웹 브라우저와 웹 서버 간의 통신을 보호하기 위해 사용됩니다. 
	SSL은 `**공개키 기반**의 암호화 방식`을 사용하여 데이터의 기밀성과 무결성을 보장합니다. 
	하지만 SSL은 중요한 정보를 탈취할 수 있는 Heartbleed와 공격자가 암호화된 데이터를 해독할 수 있는 POODLE 등의 취약점이 발견되었고, 이를 보완하기 위해 TLS로 대체되었습니다.
	
-  **TLS (Transport Layer Security)** - Transport Layer에서 보안
	TLS는 SSL의 후속 버전으로 개발되었습니다. TLS는 SSL의 취약점을 보완하고 보안 강화를 위해 개선된 버전입니다. TLS는 `공개키 기반의 암호화 방식`을 사용하여 데이터를 보호하며, 현재 주로 사용되는 프로토콜입니다. TLS의 최신 버전은 TLS 1.3이며, 이전 버전들에 비해 보안성과 성능이 향상되었습니다.

> 따라서 현재는 TLS가 SSL을 대체하고 있으며, 웹 브라우저와 웹 서버 간의 통신에서 주로 사용됩니다. 
> SSL과 TLS 모두 웹 사이트의 보안을 강화하는 데 중요한 역할을 합니다



##### [1-3] 대칭키 / 비대칭키(공개키)
 
**대칭키**는 암호화와 복호화에 같은 암호 키를 쓰는 알고리즘입니다.   
이는 중간에 누군가 암호 키를 가로채면 암호화된 정보가 유출될 수 있다는 단점이 있는데,   
이런 문제를 보완한 새로운 방식이 비대칭키(공개키)입니다.  
  
**비대칭키**는 암호화와 복호화할 때 키를 서로 다른 키로 사용하는 암호화 알고리즘입니다.   
타인에게 절대 노출되어서는 안되는 개인키(private key)와 공개적으로 개방되어 있는 공개키(public key)를 쌍으로 이룬 형태입니다.

> Github SSH 인증 방식에서 RSA 암호 알고리즘을 써봤다.
> 암호화 및 해독과 관련된 복잡한 수학적 계산 때문에, 대량의 데이터를 처리해야 할 경우 매우 느려진다. 또한, 이러한 유형의 암호 방식은 개인 키가 안전하게 보호된다는 가정을 전제로 한다. 개인키가 실수로 공유되거나 노출될 경우, 이와 상응하는 공개 키를 통해 암호화된 모든 메시지의 보안이 위협받게 된다.
