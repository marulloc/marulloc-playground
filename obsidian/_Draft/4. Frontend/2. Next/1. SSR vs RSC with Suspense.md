https://velog.io/@hamjw0122/Next.js-Hydration#%F0%9F%A7%90-%EB%91%90-%EB%B2%88%EC%94%A9%EC%9D%B4%EB%82%98-%EB%A0%8C%EB%8D%94%EB%A7%81%EB%90%98%EB%A9%B4-%EB%B9%84%ED%9A%A8%EC%9C%A8%EC%A0%81%EC%9D%B4%EC%A7%80-%EC%95%8A%EB%82%98%EC%9A%94

 
# SSR Hydration의 문제점
---
> SSR : 서버에서 데이터 로드 -> 서버에서 HTML 렌더링 -> 클라이언트에게 전송 -> Hydartion의 과정은 순차적이고(동기적이고) 블록킹한다.

1. `서버 데이터 페칭시간 대기하는 문제`
	- SSR은 유저가 페이지를 요청하면 그때 데이터 로드를 시작하는데, 
		- 백엔드 쪽에서 데이트 로드가 느려지거나, 동적인 데이터를 다루게되면
		- 페이지를 거의 매번 재생성해야되고, 로드가 다 될때까지 프론트서버는 HTML을 내려주지 못해
		- 즉, `유저가 아예 빈 화면을 오랫동안 보고 있을 수 있다는 문제가 존재`
2. `TTV !== TTI 문제`
	- SSR은 Hydration이 딱 한번 발생한다
		- 따라서 Hydration 전에 모든 JS청크들을 내려받을 때 까지 기다려야되는데
		- 이미 그려진 컴포넌트가 있을 수 있다.
		- 유저는 이 컴포넌트에 인터랙션을 시도하지만, Hydration이 완료되지 않았다면, 이벤트 핸들러가 부착이 안되어 있고 
		- 그로인해 유저는 클릭을 해도 동작하지 않는다는 경험을 느끼게 된다. 
		


# RSC (React Server Component)
---

> RSC는 React 18 Suspense의 Stream HTML, Selective Hydration을 이용하여
> SSR Hydration의 단점 문제를 극복했다.

> React Suspense를 사용하면 HTML을 여러개의 Chunk로 나눌 수 있고, 청크별로 전송이 가능해진다.
> 기다리는 것 없이 먼저 완성된 컴포넌트는 먼저 그려질 수 있다.

##### 장점 - React Suspense 활용하면 - Chunk로 나눌 수 있다. 
1. Streaming HTML을 이용하여 대기시간 문제 해결
	- 서버에서 HTML 파일을 스트리밍으로 전달한다.
	- Next12에서는 HTML파일을 넘겼지만, Next13에서는 RSC Payload라는 JSON 형태로 직렬화해서
	- 데이터 페칭이 완료된 서버컴포넌트를 넘긴다.
2. Selective Hydration을 이용하여 TTV !== TTI 문제 해결
	- 서버컴포넌트들을 그리기 위한 JSON 을 받으면 렌더링을 시작하고, 먼저 도착한 서버컴포넌트들에 대해 부분적으로 Hydration을 진행해서 먼저 그려진 컴포넌트들은 인터랙션이 가능해졌다.

##### 렌더링 순서
- 페이지 요청이 오면 서버는 컴포넌트 트리를 순회하며 직렬화된 JSON을 구성한다.
- 대신 RSC만 실제 렌더링하고 RCC는 placeholder를 두면서 렌더링한다. 
	- Suspense로 묶인 컴포넌트들은 따로 청크가 분리되어 데이터 페칭이 완료되면 바로 렌더링해서 스트림으로 전송한다.
	- Client는 Suspense가 적용된 컴포넌트에 대한 JSON을 받으면 
		- RSC 하위에 placeholder로 처리되던 RCC에 대한 번들도 넘어오면 
		- 다른 리소스를 기다리지 않고 Selective Hydration을 진행한다.
		- 그리고 해당 컴포넌트는 인터랙션이 가능해진다.

> 직렬화 ? :  직렬화란 **특정 개체를 다른 컴퓨터 환경으로 전송하고 재구성할 수 있는 형태로 바꾸는 과정**
 


##### ?? RCC에서 왜 RSC를 직접 리턴할 수 없는가 ? 

- 서버에서 RSC가 실행되다가 중간에 RCC를 만나면 placeholder로 처리하고 넘어간다 즉 RCC는 실행되지 않아서 RSC가 리턴되지 않는다. 이런경우에 RSC로 작성했지만 클라이언트와 동일하게 동작하게 된다. 
- 대신 children을 사용하면 공통 RSC가 렌더링될때 RCC밑의 RSC가 보이게되니까 서버에서 렌더링이 가능해지는 것 


##### ?? RSC에서 왜 RCC로 함수를 전달 할 수 없는가 ? 

RSC는 직렬화를 하는데 
- 직렬화란 **특정 개체를 다른 컴퓨터 환경으로 전송하고 재구성할 수 있는 형태로 바꾸는 과정**이라고 할 수 있다. 우리가 흔히 사용하는 JSON.stringify함수가 바로 직렬화를 수행하는 함수이며, JSON.parse가 역직렬화를 수행하는 함수다 함수의 실행 컨텍스트, 스코프, 클로저까지 직렬화할 수는 없기 때문에 function은 직렬화가 불가능한 객체로 분류되는 것이다.
즉 함수는 직렬화 할 수 없어서다. 

 