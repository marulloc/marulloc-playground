
# React 에서 Rendering이란
---
> 리액트 렌더링은 1.렌더, 2.커밋 단계로 나눠진다.

- 함수가 호출되는 것을 `Render`라고 하고, 이 결과물은 VDOM의 한 노드로 JS 객체다.
- 생성된 결과물의 VDOM이 실제 DOM에 적용되는 것을 `Commit`이라고 한다. 


리액트는 App 컴포넌트를 실행하면서 
재귀적으로 모든 컴포넌트들을 호출하면서 컴포넌트들을 만든다.

리액트는 상태변화요청을 처리할때 그 함수를 재실행시켜서 다시 VDOM 노드를 만들면서 
새로운 VDOM을 만들고 기존의 VDOM과 비교한다. 




# Re-Rendering
---
리액트는 렌더링을 할 때(함수형 컴포넌트를 호출할 때), 각 컴포넌트마다 FiberNode라는 것을 만드는데 
FiberNode에는 각 상태가 저장된다. 


1. 한 함수형 컴포넌트가 호출되면 useState의 초기값을 컴포넌트에 대응하는 파이버노드에 저장한다.
2. 그리고 자식 컴포넌트를 재귀적으로 호출하면서 VDOM 노드를 만든다
3. setState 함수가 호출되면, 새로운 상태를 파이버노드에 적용한다.
4. 파이버노드가 변경된 함수형컴포넌트는 재호출되며 새로운 VDOM 노드를 만든다. 
	1. 상태값을 파이버노드에서 가져와서 사용하게 된다.
	2. 그리고 자식 컴포넌트들을 재귀적으로 똑같이 호출하면서 VDOM 노드들을 만들게된다.


React는 그 상태업데이트 요청을 버퍼에 넣어두고잇다가 
약 16ms 마다 그 상태업데이트를 배치로 처리하게 되지 
배치로 처리하면서 FiberNode를 업데이트하고

FiberNode가 바뀐 함수형컴포넌트들을 재호출해서 다시 JSX를 받아 VDOM노드를 만들고 
새로운 VDOM 이 완성되면 기존의 VDOM과 diffing이라는 비교과정을거친후 
실제 변경된 부분만 실제 DOM에 반영시켜

# Re-Rendering Optimization - Memoization
---
- 리액트는 변경이 일어난 지점에서부터 재귀적으로 자식들을 모두 호출해서 새로운 VDOM을 만든다. 
- 그래서 상위의 컴포넌트가 리렌더가 일어나면, 무거운 작업들을 진행해야 된다. 

> 이런 문제를 해결하기 위해서 `Memoization`을 사용한다.

- React.memo
	- 컴포넌트를 메모이제이션 할 수 있는데 
	- props로 전달되지 않은 부모의 상태가 변경되면
	- 리액트는 이전에 생성되었던 컴포넌트의 결과물을 그대로 가져다 쓰게 된다. 
	- 여기서 주의할 점이 있다. `React.memo는 얕은비교`
		- 함수를 포함한 객체형태를 props로 전달하게 되었을 경우
		- 부모가 재실행 되면서 객체는 재생성된다. 즉 참조값이 달라진다.
		- `React.memo는 얕은비교`(주소값만 비교)하기 때문에 실제 내용물은 달라지지 않았어도
			- 주소값이 바뀌었으면, 다른 값이라 판단하고 메모이제이션된 결과물을 재사용하지 않고 리렌더링 (호출)을 진행한다. 
- 객체의 참조값이 바뀌는 것을 이용해서 메모이제이션을 사용하려면
	- useMemo와
	- useCallback을 사용하면 된다. 


# 재조정
---
> 이전 렌더링 결과와 현재 렌더링 결과를 비교하고 변경된 부분을 갱신하는 작업 

Case
1. 리렌더링 후 엘리먼트가 (컴포넌트 자체) 바뀌었을때
2. 리렌더링후 엘리먼트의 순서가 바뀌었을 때 


변경된 VDOM을 비교하는 과정을 Diffing이라고 하며
Diffing은 다음과 같이 일어난다. 
- Fiber Node의 type 비교 (엘레멘트 변경 여부 확인)
- Props 비교 
- Children 비교 -  `Key` Props의 역할 
	- React는 Children의 상태를 비교할때는 순서로 비교한다.  
	- 동적으로 앞뒤로 추가되고 삭제되는 리스트에서 실제 state와 다른 값을 가리키는 경우가 있는데
	- FiberNode와 컴포넌트의 맵핑이 제대로 안되서 발생하는 현상이다.
		- 새 컴포넌트가 앞으로 추가되었는데, FiberNode는 추가되지 않아서 이상한 순서로 맵핑됨
	- 이때 Key Props를 사용하면
		- 추가되는 컴포넌트에 새로운 FiberNode가 맵핑되어, 제대로 상태를 적용할 수 있다,
		- 뿐만 아니라, 렌더링 최적화 차원에서 React는 순차적인 리스트의 엘리먼트들에서 앞의 원소가 추가되면 뒤에있는 원소들은 새롭게 렌더링 해야 되는 것으로 판단해서 다 리렌더링 하게 되는데 
			- Key Props가 있으면, 새로운 노드가 아님을 알 수 있고, 리렌더링 하지 않는다





# Fiber 
---
리액트는 렌더링을 할 때, 각 컴포넌트마다 FiberNode라는 것을 만드는데 
FiberNode에는 각 상태가 저장된다. 