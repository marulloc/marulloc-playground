https://jwprogramming.tistory.com/54
https://ssocoit.tistory.com/263

> 이거 다시 읽어봐 https://chat.openai.com/c/a8325846-a4b8-420b-85f6-abbaa8ca9903



----
Okay, 알아들었어 이제 정리해볼께 

자 렌더링 파이프라인의 Operation 과정에서 

렌더트리가 생성되고 

레이아웃 단계를 거치면서 스타일 단위 변환과 좌표계산등이 이뤄지고 
이 정보를 렌더트리에 업데이트해 

그리고 페인트 단계에서는 
그 렌더트리 정보를 가지고 색상같은 정보를 픽셀에 뿌리기 위한 값을 계산해 

그리고 그 렌더트리 정보를 바탕으로 
컴포짓단계에선 컴포지팅 쓰레드가 레이어의 합성을 진행하고 
이를 GPU 프로세스에게 합성된 결과물을 전달하여 실제 화면이 그려지지 


최적화 관련된 얘기를 할 수 있는 부분은 2개가 있어
1. 좌표 값을 변경시키는 작업은 Reflow와 Repaint, Composite 모두를 유발하므로 
	- 만약 애니메이션을 JS로 작성한다면
	- 절대 위치를 사용하는 `position: absolute`나 `position: fixed`와 같은 스타일은 요소를 일반적인 문서 흐름에서 제거하여, 해당 요소의 변경이 주변 요소에 미치는 영향을 최소화할 수 있습니다. 이는 리플로우의 범위를 제한하여 성능을 개선할 수 있습니다.

1. 애니메이션 관련 얘기를 하자면 "Layer" 가 핵심이야
	- 레이아웃 시작되는 시점부터 브라우저는 렌더링 최적화를 위해 요소들의 집합을 Layer 라는 것으로 분리해 - 복잡한 화면을 변경될때마다 다시 그리는건 비효율적이거든 
	- 그래서 레이어로 구분하고 , 변경이 발생하면 변경이 발생한 레이어만 다시그리기 위함이야 
	- 근데 레이어에는 그래픽스 레이어와 페인트 레이어가 존재하는데, 
		- 페인트 레이어는 일반적인 요소들의 집합으로 이뤄져있고 이것이 트리로 연결되어있어 , 
		- 근데 trasnform, opacity, will-change css 속성을 사용한 요소들은 그래픽스 레이어라고 독립적인 레이어를 가지게돼
	- 여기서 애니메이션을 최적화 할때, 그래픽스 레이어를 이용하면 
		- 컴포지팅 쓰레드가, 이 레이어의 변경을 담당하게돼
		- 즉, 메인쓰레드는 거의 적게 개입하는 것이며, 또 리플로우 리페인트 없이 컴포짓 단계로 직행하는 것을 의미하기 때문에, 브라우저 렌더링 최적화에 기여 할 수 있지
		- 또한 컴포지팅 쓰레드는 GPU의 지원을 받을 수 있어서 더 CPU는 메인 작업에 집중하고 GPU가 애니메이션을 담당하게 할 수 있어서 유려한 애니메이션을 그릴 수있어

 





----
크롬은 멀티 프로세스 아키텍처로 
UI 스레드, 스토리지 스레드, 네트워크 스레드, 렌더러 프로세스 등이 있고 
보통 탭마다 하나의 렌더러 프로세스를 갖는다.

브라우저 프로세스의 내부 Network Thread에서 정적리소스가 받아와지면
Render Process에게 IPC를 통해 페이지 렌더를 요청하게 되고 
렌더링이 시작된다. 

> IPC 도구들 : 메세지큐, 세마포어, 공유메모리 등
 


![[Screenshot 2024-04-06 at 12.17.37 AM.png]]

> UI를 그리려면 그에 맞는 자료구조가 필요한데 HTML은 DOM Tree

> 파어폭스는 gecko 게코, 사파리는 Webkit
> chrome은 blink 블링크 렌더링 엔진을 사용한다.



# Critical Rendering Path

### [ 1 ] Load Resource & Parse Resource
---
###### HTML
- `Load HTML` : 최초에 서버로부터 HTML 파일을 바이트스트림 형태로 로드하게 된다.
- `Parse HTML` : 바이트스트림 -> 문자 -> 토큰 -> 노드 -> DOM Tree를 생성
	- 토큰 -> 노드(렉싱) 변환 과정에서 `<link>` 태그를 만나면 CSS를 비동기로 로드한다. 
	- 토큰 -> 노드(렉싱) 변환 과정에서 `<script>` 태그를 만나면 JS 엔진으로 컨트롤이 넘어간다. 
	  즉 DOM 파싱이 멈추고 JS엔진으로 컨트롤이 넘어간다. JS엔진은 스크립트를 로드하거나 실행하고
	  작업이 완료되면 다시 HTML Parsing을 진행한다.


###### CSS
- `Load CSS` : 토큰에서 노드로 변경하는 시점에 `<link>` 태그를 만나면 CSS 리소스를 로드하기 시작
	- 이건 비동기로 처리된다. 
	- 그러나 "렌더링 블락(block)"에 의해, CSSOM 트리가 모두 준비될 때 까지 화면 렌더링이 블락된다.
	- 그래서 CSS 자체에는 dynamic import가 없는것 = 대신 Javascript로 `<link>`태그를 만들어서 document.head에 붙일 수는 있지
- `Parse CSS` : 바이스트림-> 문자 -> 토큰화 -> 구문 분석 -> CSSOM 트리 구성 -> 스타일 계산
	1. 바이트스트림 해석
	2. 토큰화
	3. 구문분석
	4. CSSOM 트리 구성

###### Javascript
- `Load JS` : HTML 렉싱단계에서 `<script>` 태그를 만나면 JS 리소스를 로드한다.
	- 이때 일반적인 경우 HTML Parser 중단하고 렌더링엔진에서 JS엔진으로 컨트롤이 넘어간다. 
	- `async` 경우 비동기 로드 (렌더링 엔진이 컨트롤 계속 소유) DOM Tree 생성을 중단하지 않는다. 
	- `defer` 경우 비동기 로드 (렌더링 엔진이 컨트롤 계속 소유) DOM Tree 생성을 중단하지 않는다.
- `Parse JS` : 바이트스트림 -> 문자열 변환 -> 토큰화(렉서, 토크나이저) -> AST(추상 구문트리)
	- `async` 경우 로드가 완료되면 바로 AST로 파싱되고 바이트코드 변환 후 실행
	- `defer` 경우 DOM Tree생성 이후 DOMContentLoaded 이벤트 발생 전에 AST로 파싱되고 바이트코드로 변환 후 실행


> body 요소의 가장 아래에 자바스크립트를 위치시키는 것은 좋은 아이디어이다. 
> - 스크립트 로딩으로 인해 HTML 파싱 지연이 발생하지 않아 페이지 로딩 시간이 단축
> - DOM이 완성되지 않은 상태에서 자바스크립트가 DOM을 조작한다면 에러가 발생한다.




### [ 2 ] Style / Render Tree (Attachment)
---
DOM 트리와 CSSOM 트리가 완성이되면 브라우저는 이 두개를 합쳐서 렌더트리라는 것을 만들게된다.

렌더링 엔진은 DOM 트리를 순회하며 pre-order traversal로 방문하면서
CSSOM에서 스타일을 매칭하고, 렌더객체를 생성하고 비시각적 요소를 제거하면서 
렌더트리를 구성해간다.

1. DOM Tree 순회 
	- 렌더링 엔진은 DOM 트리를 순회하며 pre-order traversal로 방문
	1. CSSOM 매칭 및 스타일 계산
		- DOM을 순회하면서 그 노드에 맞는 CSSOM을 보고, 그 노드에 매칭되는 스타일 규칙 찾기
		- 스타일 계산
			- 상속처리 : 상속 규칙을 계산하여 각 요소에 적용 
			- 최종 스타일 결정 : 여러 규칙이 적용될 경우 Cascading Order(우선순위)에 따라 결정
			- `display:none` , `<head>` 같이 시각적으로 표현되지 않을 노드는 렌더트리에서 제외
				-  `visibility:hidden` 과 같이 공간을 차지 & 보이지 않는 경우엔 렌더트리에 포함
				- 따라서 웹접근성을 위한다면 display:none 대신 "ARIA"나 "Visibility" 이용
	2. 렌더 객체 생성
		- 스타일 규칙을 찾으면서 각 DOM 노드에 대응하는 랜더객체를 생성한다. 
		- 렌더 객체에는 DOM과 위치/크기와 같은 레이아웃 정보와 색상/폰트 같은 시각적 속성을 포함
	3. 렌더트리 구조 형성
		- 생성된 렌더 객체들은 DOM 트리 구조를 따라 트리 형태로 조직된다. 
		
2. DOM Tree 전위 순회가 완료되면 렌더트리가 완성된다. 
	- 페이지의 시각적 렌더링을 위한 모든 정보가 포함된다. 



### [ 3 ] Layout (ReFlow)
---
레이아웃 단계에서는 각 요소의 실제 화면에서의 위치와 크기를 계산합니다. 
이는 렌더 트리에 있는 정보를 기반으로 
각 요소가 뷰포트 내에서 어느 위치에 배치될지, 얼마만큼의 공간을 차지할지를 정하는 과정입니다.

- 조건부 스타일 : 미디어쿼리 등의 조건에 의해 적용되는 스타일 결정
- 크기 단위 변환 : 각 상대 단위들을 px로 변환하여 결정 
- 박스모델 계산 : 요소의 margin, border, padding ,content 가 실제 화면에 차지하는 공간 계산

이걸 계산해서 렌더트리를 업데이트 한다.

> Attachment 작업에서의 스타일 처리와 레이아웃 작업에서의 스타일 처리
> - Attachment : 스타일 상속, 선택자의 우선순위 해결 = "어떤" 스타일이 적용되는지
> - Layout(Reflow) : "어디에", "얼마나" 요소가 표시될지를 결정하는 작업




### [ 4 ] Update Layer Tree 생성 (최신 브라우저)
---
렌더트리를 한 번에 처리해서 화면에 표현하지 않고 
여러 레이어로 나눈다음 순차적으로 레이어를 합성해서 표현하게 되는데 

Layer는 렌더링될 요소들을 층 형태로 나누어둔 것을 의미합니다.
그 Layer들을 Tree형태로 만드는 작업을 진행하고 나중에 Composite 단계에서 Layer를 합성해서 화면에 그림

 
- Paint Layer : **페인트 레이어**는 웹 페이지의 시각적 요소를 페인팅하는 과정을 관리
	- 뷰포트에서 같은 좌표 공간에 위치하게 될 렌더객체(렌더트리의 노드)는 같은  Layer에 속한다. 
- Compositing Layer :복잡한 애니메이션, CSS 변환, 빠른 스크롤링 등의 동작을 처리하기 위한 Layer
	- 특정 CSS 속성 사용으로 인해 생성됩니다. 주로 `transform`, `opacity`, `filter` 같은 속성이 있는 렌더객체라면 Compositing Layer로 빠진다.
	- `position: fixed`
	- `transform`
	- `video, canvas`

 


### [ 5 ] Paint (RePaint)
---
렌더링 엔진은 Render Tree 기반으로 페인트 레코드(Paint Records)를 생성합니다.  
 
- **페인트 레코드**는 각 요소를 어떻게 그릴지에 대한 명세를 담고 있습니다. 여기에는 요소의 위치, 크기, 색상, 텍스트 스타일 등이 포함됩니다.
- 페인트 레코드의 생성은 렌더 트리에서 각 요소를 순회하면서 진행됩니다. 이때, 각 요소의 시각적 속성을 기반으로 구체적인 그리기 명령이 정의됩니다.




### [ 6 ] Composite (최신)
---
`렌더링 엔진 Compositing Thread` 가 담당하여 Layer Tree와 Paint Record를 이용하여 
레이어들을 합성하는 작업을 허는데
Graphic Layer의 경우엔 GPU가 담당하여 화면의 업데이트를 도운다. 

이 과정에 끝나면 `브라우저의 GPU 프로세서`로 결과물을 넘겨서 화면을 그리도록 만든다. 

 
> GPU 가속은 왜 성능이 좋을까? 
> - CPU의 부담을 줄일 수 있습니다. 이는 CPU가 다른 작업(예: 자바스크립트 실행, 이벤트 처리)에 더 집중할 수 있게 해, 전체 시스템의 효율성을 높입니다. 
> - CPU는 주로 연속적인 작업 처리에 강하지만, 한 번에 처리할 수 있는 작업의 수가 제한적입니다. 반면, GPU는 수백에서 수천 개의 작은 코어를 가지고 있어 동시에 많은 작업을 처리할 수 있습니다. 이런 특성 덕분에, 화면에 그려지는 각 픽셀의 계산과 같은 대량의 데이터 처리 작업을 효율적으로 수행할 수 있습니다.

> GPU 가속 활용법 - Compositing Layer를 유발하는 CSS 속성을 사용하면 GPU 가속 활용 가능
> - Transform과 Opacity - translate3d, rotate3d, scale3d
> 	- `translate3d(0, 0, 0)` 같이 Z값에 변화를 주지 않아도, 이를 사용함으로써 GPU 가속을 활성화하여 2D 애니메이션의 성능을 향상시킬 수 있습니다.
> - will-change 속성
> - WebGL

GPU 가속은 성능을 크게 향상시킬 수 있지만, 과도하게 사용할 경우 메모리 사용량 증가, 배터리 소모 증가, 그리고 때로는 성능 저하를 초래할 수도 있습니다. 따라서 필요한 경우에만 적절히 사용하는 것이 중요합니다.

메모리 사용량을 증가시킬 수 있으며, 이는 특히 모바일 장치와 같은 리소스가 제한된 환경에서 성능 저하를 초래할 수 있습니다. 따라서, 실제로 성능 향상이 필요한 요소에 대해서만 사용하는 것이 좋습니다.




# 브라우저 렌더링 최적화 
---

#### Reflow 최소화

Reflow는 RePaint와 Composite 단계도 수반되기 때문에 비용이 많이 드는 작업이다. 
- CSS 클래스를 통한 스타일 변경을 상
- **최소화 전략**:
    - DOM 변경을 일괄적으로 처리하고, 가능한 한 변경 횟수를 줄입니다.
    - CSS 클래스를 통한 스타일 변경을 사용하여, 한 번의 Reflow로 여러 스타일 변경을 적용합니다.
    - 레이아웃 정보(예: offsetWidth, scrollTop 등)를 읽는 작업과 DOM 변경 작업을 분리하여 배치합니다.


### Compositing Layer - Compositer Thread - GPU => Animation 

Composite(합성) 단계는 컴포지터 쓰레드를 사용하여 수행되기 때문에
이 과정이 진행되는 동안 메인 쓰레드는 다른 작업을 계속 처리할 수 있습니다.  
그래서 Composite만 발생시키는 요소들을 통해 애니메이션을 만들면 최적화 가능

그니까 Reflow를 발생시키는 `left` 대신 `transform: translateX` 를 이용해 애니메이션 구현해
 
1. **`transform`**:
    - 요소의 위치, 크기, 회전, 기울임 등을 변화시키는 데 사용됩니다.
    - 예: `transform: translateX(50px);`는 요소를 수평으로 50픽셀 이동시킵니다.
2. **`opacity`**:
    - 요소의 투명도를 조절합니다.
    - 예: `opacity: 0.5;`는 요소를 50% 투명하게 만듭니다.
 

  
 
 