#### www.naver.com을 입력하면 벌어지는 일 
 
> URI는 식별자고 / URL은 위치지정자임 


- 브라우저 프로세스에서 UI 인터페이스에서 입력이 발생
- url 요청이면 브라우저 프로세스의 네트워크 쓰레드가 작업 시작함
	- DNS 질의 시작 
	- 운영체제 위임
		- host 파일 탐색


 

브라우저를 쓰니까 HTTP를 쓸거고 HTTP는 TCP연결을 기반으로 하기 때문에
IP 주소를 찾으면 TCP 연결을 진행한다. 

TCP 연결이 성공하면 HTTP 요청이 전달되고 응답을 받게된다. 

---

경력개발자의 경우 더 추가해야된다. 

GSLB 혹은 CDN 서비스도 추가해야된다. 

> CDN 사용 이유 
> GSLB 구현할때 DNS + 

서비스가 CDN을 이용한다면, 
CDN 서비스가 유저의 요청 IP를 보고 가장 반응성 좋은 서버의 IP를 전달해주거나 
정적 리소스는 CDN이 바로 리턴해주기도 준다, 

GSLB는 ? 
Helth Check를 해주는데 
이때 사용하고있는 서버가 죽으면 가장 반응성 좋은 다른 서버와 연결시켜준다. 

GSLB를 구현하고 있었고
서울서버에 로그인을 한 유저가 있었는데 
서울 서버가 죽어서 GSLB는 부산에 있는 서버에 유저를 연결시켰다.
새로운 서버와 연결되었는데 어떻게 로그인 세션이 유지될 수 있을까? 
어떻게 아키텍처를 구성해야되나 ?


- 무중단배포 하면 helth Check 얘기가 나오고 또 장애대응 얘기를 나올 수 없다. 



-----


# 1. 브라우저의 DNS 캐시 확인
---
도메인을 입력받은 응용 계층(Application Layer)의 브라우저부터 시작
브라우저는 실제 요청을 어디로 보내야 되는지 확인하기 위해 브라우저에 내장된 DNS 캐시를 확인
만약 브라우저 캐시에도 Domain과 매칭되는 IP 주소가 없다면 OS에게 이 작업을 위임

# 2. 운영체제의 DNS 캐시 확인 및 DNS 조회
브라우저로 부터 DNS 조회 요청을 받은 운영체제는 운영체제 내부의 DNS 캐시를 확인. 
운영체제가 알고있는 IP주소가 있다면 바로 브라우저에게 IP주소를 알려주겠지만,
만약 없다면, 운영체제가 알고 있는 DNS 서버에 IP를 알려달라는 요청을 보냄

요청은 보통 운영체제의 전송계층(Transport Layer)에서 UDP를 사용하여 전송 
이때 요청을 받은 DNS 서버에서도 알지 못하는 IP라면 전세계에 위치한 Root DNS 서버로 조회 요청을 보내고 이 Root DNS 서버에서부터 재귀적으로 우리 OS가 요청한 IP를 찾아서 응답을 받게됨

그래서 특히 지역별로 방문한 적이 없는 주소의 사이트를 방문하면 사이트 접속까지 오래걸리는 것 
그리고 이 DNS 조회 작업은 네트워크I/O 이기 때문에 비동기작업으로 진행되어 
운영체제나 브라우저는 다른 작업을 진행 할 수는 있지만
실제 요청을 보내는 것은 IP를 알기 전까지 요청을 보낼 수 없게됨

# 3. TCP 연결 수립 : 3-way Handshake
OS로부터 IP 주소를 얻었다면, 이제 브라우저는 그 IP에 위치한 서버와 TCP 연결을 시도  
데이터를 안정적으로 송수신하기 위한 절차이며 다음과 같은 작업을 하게됨
이 작업은 브라우저가 운영체제에게 위임하고 운영체제의 Trasnport Layer에서 이뤄짐.
1. SYN
   브라우저는 서버에게 연결을 시작하려는 의도를 알리기 위해 IP 주소로 SYN 패킷을 보내 연결을 시작
2. SYN-ACK 
   SYN 패킷을 받은 서버는 클라이언트의 연결 요청을 수락했으며 서로간의 통신 준비가 완료되었다는 사실을 알리기위해 요청을 준 클라이언트에게 SYN-ACK 패킷을 응답
3. ACK
   클라이언트는 SYN-ACK를 응답받으면 ACK 패킷을 보내 연결을 확정
   이 단계가 완료되면 TCP연결이 성공적으로 수립됩니다. 

# 4. HTTP(S) 요청 전송 (응용 계층)
OS에게 IP를 알아오고 TCP연결을 수립하라는 요청이 모두 완료가되면 
브라우저(Application Layer)는 요청보내는 도메인이 http로 시작하면 HTTP, https 로 시작하면 HTTPS 프로토콜을 사용하여 요청 메세지를 생성하고 OS에게 이 메세지를 전달 

# 5. 패킷생성 전송
HTTP(S) 프로토콜을 사용하여 만들어진 메세지에 OS의 Transport Layer에선  TCP프로토콜 이용하여 메세지를 분리하고 프로토콜에 맞는 헤더를 메세지에 붙입니다. 그리고 OS의 Network Layer에서 IP혹은 그에 맞는 프로토콜을 사용하여 메세지를 분리하고 헤더를 삽입. 
이제 다음단계로 요청 조각들을 넘깁니다.

# 6. 바깥세상으로
내 컴퓨터를 벗어난 패킷들은 회사의 gateway와 각 통신사(ISP)의 라우터들을 거치면서 각 패킷이 담긴 헤더가 다시 조합되고 분해되는 것을 반복되다가 네트워크를 유람하다가 우리가 원하는 IP에 도착.

그리고 나서 해당 IP에 위치한 서버에서 80번 혹은 443번 포트를 리스닝하고 있는 소프트웨어가 요청을 받아 클라이언트에서 요청한 리소스를 위와 같은 작업을 거쳐 전송하게 됩니다.

# 7. 돌아온 응답 
컴퓨터로 들어온 응답은 아까의 역순으로 OS의 Network Layer -> Transport Layer를 거쳐 순서에 맞게 재조합되면서 멀쩡한 데이터가 되고 OS는 이 요청을 받아야하는 포트번호를 가진 application에 전달하게 됩니다. 

브라우저에게 URL을 써서 응답을 받았으니 HTML 파일을 받게됨

# 8. 필요한 것 모두 다 
브라우저는 서버로부터 받은 HTML 문서를 파싱하고,  
DOM 트리를 만들면서 `<link>` 태그가 있다면 CSS를 
`<scrpipt>` 태그가 있다면 JavaScript 파일을 요청하여 받아오며, 
최종적으로 웹 페이지를 사용자에게 렌더링



---



### 1. 주소 입력 및 초기 처리

- 사용자가 브라우저의 주소 창에 URL(Uniform Resource Locator)을 입력합니다.
- 입력된 URL은 브라우저의 UI 인터페이스에 의해 처리되며, 브라우저 프로세스는 네트워크 요청을 처리할 준비를 시작합니다.

> URL vs URI
> URL은 웹 리소스의 위치를 나타내는 반면, 
> URI(Uniform Resource Identifier)는 리소스를 식별합니다.
### 2. DNS 조회

- `브라우저 프로세스의 네트워크 쓰레드`브라우저 프로세스의 네트워크 쓰레드 요청한 URL의 도메인 이름을 IP 주소로 변환하기 위해 DNS(Domain Name System) 조회 과정을 시작합니다.
- 브라우저는 먼저 자체 DNS 캐시를 확인하고, 없다면 운영 체제의 DNS 설정을 사용하여 DNS 서버에 질의를 보냅니다. 운영 체제는 일반적으로 로컬 호스트 파일, OS의 DNS 캐시, ISP의 DNS 서버 순으로 조회를 시도합니다.

### 3. TCP 연결

- DNS 조회를 통해 얻은 IP 주소를 바탕으로, 브라우저는 해당 서버와의 TCP(Transmission Control Protocol) 연결을 시작합니다. 이 과정은 3-way handshake를 통해 수행됩니다.
	1. SYN (신)
	   브라우저는 서버에게 연결을 시작하려는 의도를 알리기 위해 IP 주소로 SYN 패킷을 보내 연결을 시작
	2. SYN-ACK (신-액) 
	   SYN 패킷을 받은 서버는 클라이언트의 연결 요청을 수락했으며 서로간의 통신 준비가 완료되었다는 사실을 알리기위해 요청을 준 클라이언트에게 SYN-ACK 패킷을 응답
	3. ACK (액)
	   클라이언트는 SYN-ACK를 응답받으면 ACK 패킷을 보내 연결을 확정
	   이 단계가 완료되면 TCP연결이 성공적으로 수립됩니다. 
### 4. HTTP/HTTPS 요청

- TCP 연결이 성립되면, 브라우저는 HTTP(HyperText Transfer Protocol) 또는 HTTPS(HyperText Transfer Protocol Secure) 요청을 서버로 전송합니다. HTTPS의 경우 SSL/TLS 핸드셰이크를 통해 암호화된 연결이 추가로 수립됩니다.

### 5. 서버 응답 및 리소스 다운로드

- 서버는 브라우저의 요청을 처리하고, 요청한 웹 페이지의 HTML 문서를 비롯한 필요한 리소스(CSS, JavaScript, 이미지 파일 등)를 응답으로 전송합니다.
- 브라우저는 받은 HTML 문서를 파싱하면서 필요한 외부 리소스를 추가로 요청합니다.