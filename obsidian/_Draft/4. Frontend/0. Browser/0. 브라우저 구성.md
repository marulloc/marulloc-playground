
https://blog.areumsheep.vercel.app/contents/how-browser-works/

# 브라우저 구성 
![[Pasted image 20240407005038.png]]
엔진은 : 특정 작업을 수행하는 소프트웨어를 말하는 것 


# Chromium
---
> 크로미움은 V8이라는 자바스크립트 엔진과 Blink라는 렌더링 엔진을 사용하는 오픈소스 웹 브라우저입니다. 

크롬이 크로미움 기반으로 만들어졌다는 것은 
오픈 소스인 크로미움 브라우저 코드 위에 살을 덧붙여 개발되었다는 의미입니다. 




# Chromium 멀티 프로세스 아키텍처
---
- `브라우저 프로세스` : 화면외에 브라우저의 UI영역 제어, 네트워크 요청, 파일접근
	1. 네트워크 쓰레드
		- 웹 페이지 로딩, AJAX 요청 등의 네트워크 요청 처리
		- 로컬 파일 시스템에 대한 접근 관리

- `렌더러 프로세스` : 화면을 어떻게 칠할 것인지 파싱, 자바스크립트 파싱과 실행 담당
	- 탭별로 하나씩 생성됨
	1. `메인 스레드`
		- DOM 파싱 : 메인 스레드가 `Blink 렌더링 엔진` 을 이용, HTML 파싱 및  `DOM Tree` 생성
		- CSS 파싱 : 메인 스레드가 `Blink 렌더링 엔진` 을 이용, CSS 파싱 및  `CSSOM Tree` 생성
		- 레이아웃 계산 : 메인 스레드가 `Blink 렌더링 엔진` 을 이용, `Layout Tree` 생성
		- 페인팅 준비 : 메인 스레드가 `Blink 렌더링 엔진` 을 이용, `Paint Record` 생성
		- 자바스크립트 실행 : 메인 스레드가 `V8 JS 엔진`을 이용하여 `AST`로 파싱 및 실행 담당
	
	2. `컴포지터 스레드` : 합성 단계를 컴포지터 스레드가 담당하여 메인스레드는 다른 작업 할 수 있음
		- 레이어 합성 : 페이지를 구성하는 여러 레이어들을 합쳐서, 보여질 화면을 준비
		- 스크롤 및 애니메이션, 사용자 스크롤 동작과 CSS 애니메이션 부드럽게 처리  
	
	3. `워커 스레드` 
		- web worker : 자신의 탭마다 달려있음 - UI Block을 피하기 위한 연산용으로 쓰임
		- service worker : 활성탭이 열려있지 않아도 백그라운드에서 실행 - 프록시, 오프라인 처리

- `GPU 프로세스` 
	- 그래픽 처리 
		- 컴포지터 스레드가 준비한 정보를 바탕으로, 실제 화면에 픽셀을 그려내는 작업을 GPU에게 전달
	- 픽셀 렌더링
		- 렌더트리와, 레이어정보를 사용하여 화면에 표시될 픽셀을 그려내고, 디스플레이로 전송



### 멀티 프로세스 예시
---

##### 파싱 차단 리소스 `<script>` Javascript

- 렌더러 프로세스의 메인 스레드가 블록되는 이유는 HTML 문서가 순차적으로 파싱되고 처리되기 때문

1. 렌더링 프로세스의 메인 스레드는 blink 엔진에서 v8엔진으로 컨트롤을 옮기고 
2. IPC를 통해 렌더링 프로세스가 브라우저 프로세스에게 JS 로드를 위임하고 렌더링 메인 스레드는 블락됨
3. 브라우저 프로세스의 네트워크 쓰레드가 script 파일을 로드함
4. 로드가 완료되면 렌더링 프로세스의 메인쓰레드에게 전달 
5. 메인쓰레드는 v8엔진을 이용하여 바이트스트림을 문자로, 토큰으로, AST로 파싱하고 실행한다.

- async 속성을 사용한다면
	- 메인스레드는 블락되지 않고 네트워크 스레드가 JS를 로드한다.
	- script가 도착하면 바로 렌더링 프로세스의



##### 렌더링 차단 리소스 `<link>` CSS

- script 로딩과 달리, CSS 로딩이 메인 스레드를 블록하지 않는 주된 이유는 CSS는 웹 페이지의 스타일을 정의하는 데 사용되며, HTML 문서의 구조를 변경하지 않습니다.따라서 "파싱 블락" 은 일어나지 않는다.
- 그러나, "렌더링 차단"은 일어난다.
	- 웹 페이지의 렌더링은 CSSOM이 준비될 때까지 지연될 수 있습니다. 즉, CSS 로드와 파싱이 완료되어야만 브라우저가 렌더 트리를 구축하고 페이지를 렌더링할 수 있습니다.


 

---


 
