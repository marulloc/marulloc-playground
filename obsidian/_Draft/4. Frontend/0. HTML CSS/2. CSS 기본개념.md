> Cascading Style Sheet 
> Cascading : 여러 단계를 거치며 내려오는 현상을 묘사할 때 쓰는 단어로, 스타일규칙이 여러 출처로부터 결합되어 최종적인 스타일을 결정하는 과정을 의미한다.


https://prmblogs.tistory.com/13
https://joonfluence.tistory.com/274

# Box Model
---
> 모든 HTML요소는 박스모양으로 구성되며 이것을 박스모델이라고 부르는데
> 박스모델은 HTML요소를 컨텐트 > 패딩 > 보더 > 마진으로 구분합니다. 
> 박스 모델의 종류에는 블록박스와 인라인 박스로 구분됩니다. 

##### 블록 박스
- 컨텐트, 패딩, 보더, 마진 영역을 모두 조정가능하고 시각적으로 차이가 보인다. 대표적으로 `div` 태그
- 기본적으로 뷰포트의 전체 너비를 차지합니다. 남은 영역은 마진으로 채워지거나, CSS를 통해 조정 

##### 인라인 박스
- 컨텐트, 패딩, 보더, 마진을 조정할 수 있지만, 상하 마진은 시각적으로 표현되지 않는다..대표적으로 `span` 
	-  상하 마진은 적용되나, 라인 박스의 높이에 영향을 주지 않아 시각적으로 눈에 띄는 변화없다.
	- 상하 간격 조정을 위해서는 `line-height`를 조절할 수 있습니다.
- 컨텐트의 크기에 따라 공간을 차지하며, 기본적으로 `width`와 `height`를 직접 조절할 수 없습니다 

> 라인박스 : 인라인 요소들이 배치되는 가상의 컨테이너로,  
> 텍스트 라인(페이지마다 텍스트가 배치되는 가로 줄)마다 라인박스가 존재한다.

##### 속성변경
> display 속성을 조작하여 박스모델을 조정할 수 있다.
- `display : inline` = 요소를 인라인 박스로 변경한다.
- `display : block` = 요소를 블록 박스로 변경한다.
- `display : inline-block` = 인라인으로 배치하되, `너비 높이 마진 패딩`을 조작가능
- `display : inline-flex` = 인라인 요소로 배치하되, flex 컨테이너의 속성을 가지게 된다.

##### 박스모델 계산방식
> box-sizing 속성을 조작하여 요소의 크기 계산 방식을 변경 할 수 있다.
- `box-sizing : border-box` = 요소의 너비와 높이 안에 패딩과 보더를 포함하게 된다. 
	- 전체크기를 쉽게 제어 
- `box-sizing : content-box` = 기본 CSS 박스모델로, 요소의 너비와 높이가 컨텐트영역만 포함

 


# Cascading Order
---
> Cascading Order는 CSS 에서 스타일이 충돌할 때 어떤 규칙이 우선적으로 적용될지 결정하는 규칙이다.

1. 중요도 
	1. `!important`  규칙이 붙은 스타일이 가장 높은 우선순위 
	2. 인라인스타일 
2. 명시도
	1. ID 선택자
	2. 클래스 선택자 / 가상클래스
	3. 태그 선택자 / 가상요소 
	순서로 결정되며 
3. 작성순서
	- 명시도가 같은경우 가장 마지막에 작성된 스타일이 적용되는데 




# Inherit
---
> 특정 속성의 값이 부모요소에서 자식요소로 전달되는 것을 의미한다. 


##### 상속되는 속성
- 주로 텍스트 관련 속성들로 color, font-size, line-height등이 자동으로 상속된다.
- 자식이 다른 값을 설정하지 않으면 부모의 속성값을 상속받게 된다. 

##### 장점
- body에 폰트스타일을 적용해서 모든 텍스트 요소에 적용할 수 있는 일관성과 유지보수성 

##### 상속제어 
- `padding : inherit` : 상속 강제 - 자동 상속되지 않는 레이아웃 속성들에 대해서 상속 할 수도 있다.
- `color : initial` : 상속 방지 - 자동으로 상속되는 텍스트 관련 속성들의 상속 방지
- `all : initial | inherit` : 모든 속성을 상속하거나 상속받지 않도록 





# Selector
---
> CSS 속성 값을 적용하기 위해 어떤 HTML 요소를 선택해야 하는지 브라우저에 알려주는 것 

- `* 선택자`
- `Tag 선택자`
- `class 선택자`
- `id 선택자`
- `속성 선택자` : `a[href="naver.com"]` | `input[type="password"]`




# Pseudo-Class / Pseudo-Element
---
> 가상(의사) 클래스(`:hover`, `:focus` 등)는 요소의 특정 상태를 선택하며
> 가상 요소(`::before`, `::after`)는 실제 존재하지 않는 요소를 만들어주고 선택가능해진다. 요소의 특정 부분에 스타일을 적용 가능


##### 가상 클래스 | 의사 클래스 | 추상클래스 
- `:hover`  
- `:focus`
- `:disabled`
- `:active`
- `:nth-child(odd|even |2n | 2n+1)` : 자식 개수를 카운팅
- `:nth-of-type()` : 같은 타입의 요소 개수를 카운팅

##### 가상요소
- `::after` | `:after` ( p ::after { } )
	- content 속성에 적힌 것이 지시한 요소 오른쪽에 배치된다.
- `::before` | `:before` ( p ::before { } )
	- content 속성에 지시한 것이 요소 왼쪽에 배치된다.
- `::selection` 
	- 드래그한 영역을 의미한다. 


> after나 before를 상하 로 바꾸는 법은 ?



# CSS 결합자 (Combinator)
---
>  `>`, `공백`, `+`, `~` 같이 꺽쇠 등 기호등을 결합자라고 하며
>  결합자를 이용하여 선택자간 관계를 통해 선택을 할 수 있게 만든다. 

- 자손결합자 `space`
	- `body p { }`
	- 지정된 요소의 하위 모든 항목 얼마나 떨어져있든 다 적용하는 선택자
- 자식결합자 `>`
	- `div > li`
	- 지정된 요소의 자식만 선택하는 선택자
- 인접형제결합자 `+`
	- `h3 + p`
	- 바로 옆에 붙은 선택자와 선택자인 경우
- 일반형제결합자 `~` 틸드 ?
	- `h3 ~ p`
	- 형제관계의 해당 선택자라면 모두 적용

> `,` 쉼표는 결합자는 아니고 여러개를 동시에 선택할때 쓰는 것 

 

# Margin Collapse
---
> 마진상쇄는 떤 두 개 이상 블록 요소의 위 아래 마진이 겹칠 때, 어느 한쪽의 값만 적용되는 현상
 
##### 발생 원인 
- 부모 요소와 첫/마지막 자식의 마진이 세로로 겹칠때 
- 형제들끼리 마진이 세로로 겹칠때 

##### 해결책
- 부모에 inline-block을 주거나 flex/grid를 준다.
	- padding으로 밀어주면, 디자인 통일성이 깨진다.




# Stacking Context
---
> 스태킹 컨텍스트(Stacking Context)는 웹 페이지에서 요소들이 어떤 순서로 겹쳐 보여질지 결정하는 규칙

##### 쌓임맥락 현상
- 기본적으로 z-index를 통해, 어느 요소를 위에 그릴 수 있을지 결정 할 수 있는데
- 형제들보다 낮은 z-index를 가진 부모 밑에 있는 자식은 z-index가 아무리 높더라도 부모의 형제들 보다 위에 그려질 수 없는 현상이 있다. 

##### 쌓임맥락 생성 조건
- html 엘리먼트
- position 속성이 지정되고 z-index가 auto값이 아닐때
- opacity가 1보다 작을때 
- flex요서에 z-index가 auto 값이 아닐때 

##### 요약
- 여기서 쌓임맥락은 다른 쌓임맥락 안에 포함될 수 있고 
- 브라우저는 위에 그려질 요소를 결정하기 위해 쌓임맥락을 비교하는데
	- `먼저 부모를 먼저 비교하기 때문에 `
	- 낮은 쌓임맥락을 가진 부모의 자식들은 아무리 z-index가 높아도 
	- 그 부모의 형제보다 앞에 갈 수 없다.


##### 쌓임맥락 문제 벗어나기 위해선
- isolation : isolate 속성을 사용한다.
- React.Portal을 이용해서 DOM Tree 최상단 레벨로 아예 요소를 옮겨서 부모의 스태킹컨텍스트 비교에서 벗어날 수 있다.
