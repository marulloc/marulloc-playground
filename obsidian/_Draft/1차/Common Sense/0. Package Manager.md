
# npm 
 
- 식별자해결 문제 (dk)
	NPM은 패키지를 찾지 못하면 상위 디렉토리의 node_modules 폴더를 계속 검색합니다. 이 특성 때문에 어떤 의존성을 찾을 수 있는지는 해당 패키지의 상위 디렉토리 환경에 따라 달라집니다.
	
	예를 들어, 상위 디렉토리가 어떤 node_modules를 포함하고 있는지에 따라 의존성을 불러올 수 있기도 하고, 없기도 합니다. 다른 버전의 의존성을 잘못 불러올 수 있는 여지도 존재합니다. 
	
- 유령의존성문제 (암묵적 의존성) - hoisting
	NPM 및 Yarn v1에서는 중복해서 설치되는 node_modules를 아끼기 위해 끌어올리기(Hoisting) 기법을 사용합니

실제로 npm에서 이런 문제를 겪어본 적은 없긴 합니다만 다음과 같은 이유로 yarn berry를 선택하게 되었다. 


# yarn berry 
---
https://toss.tech/article/node-modules-and-yarn-berry

### yarn berry 왜 선택했나요 
배포시스템을 AWS Amplify로 옮기는 것을 결정하고보니 
빌드타임에서 1초마다 0.몇 달러씩 과금되는 것을 확인했는데 이때 레거시 솔루션들의 
젠킨스에서 빌드타임을 확인해보니 20분정도 걸리는 것들도 꽤 있었습니다.
그래서 과금 비용을 낮추고자 zero-install을 제공하는 yarn berry를 선택하게 되었습니다 .


### yarn berry에 대해 설명해주세요 
주요 특징으로 `Plug n Play` 와 `zero-install` 있습니다. 

yarn 초기버전과 npm은 `node_modules` 폴더를 사용해 프로젝트의 의존성을 관리했는데 
`node_modules`는 
- 프로젝트의 의존성이 많을 수록 디스크공간을 많이 차지하고 의존성이 많을 경우 설치하는 시간이 김
- 여러 패키지가 서로 다른 버전의 의존선ㅇ을 요구하는 경우 node_modules 구조가 복잡해지는 `dependency hell` 문제를 야기하여 의존성 충돌 문제가 발생합니다.
- 또한 각자 시스템에서 알아서 설치하니까 버전 불일치나 의존성 누락 `it works on my machine` 문제 초래한다. 

##### pnp.js 파일
즉 `node_modules` 방식은 의존성을 디스크에 물리적으로 저장하고 파일 시스템 기반으로 관리합니다. 
반면, Yarn Berry의 PnP 방식은 의존성을 `.pnp.js` 파일을 통해 가상적으로 관리합니다. 
실제 패키지가 어느 위치에 존재하는 지 명시되어 있어서 runtime에 resolution 로직을 제공하여 Node.js가 필요한 패키지를 메모리에서 직접 찾아 로드하게 된다. 
즉 이상한 의존성을 찾아서 설치하는 경우는 없어서 개발환경간 일관적인 의존성 관리를 보장합니다.

##### 압축파일과 함께 
또 의존성 파일을 압축파일로 관리하고, 의존성이 중복되는 경우 기존에 존재하던 의존성을 재설치 하지 않고 참조하기 때문에 디스크 공간도 절약됩니다. 그대로 형상관리 플랫폼에 올리게되면 
다른 개발환경에서도 다른 설치 없이 바로 실행할 수 있어서 일관적인 개발경험을 제공할 수 있습니다. 


### yarn berry 어려움은 없었나요 ? 

> peer dependency 문제 [[2. Dependency]]

peer dependency에게 크게 혼난 경험이 있습니다. 

Ag-Grid라는 라이브러리를 사용한 적이 있는데 이 친구의 peer dependency가 충족이 안되었다. 
3개의 패키지를 설치해야되었는데 3개 모두 각자 서로의 peer dependency가 충족이 안되었고 
프로젝트에서 사용하던 React 버전과 호환이 맞지 않아서 
yarrc.yml 파일에서 ag-grid의 각 패키지의 peer dependency를 조정해주고 프로젝트의 React 버전으로 peer dependency를 바꿔줘야 했는데.. 참 오래걸렸던 것 같다.




# pnpm 
---

### 왜 yarn berry에서 pnpm으로 넘어갔나요 

기술적으로 크게 검토 한 것은 아니지만  

인력이탈이나 유입이 
프로토타입 개발이라 돈 안쓰면서 배포하고 싶어서 Vercel을 선택했는데 
이왕 선택한김에 pnpm과 turborepo 세트를 경험해봤다. 근데 너무 경험이 좋았다.  
 
모노레포로 workspaces보다 Turborepo가 훨씬 간결하고 관리하기 용이하다는 판단이 들었으며 
신규 개발에 많은 의존성을 필요로 하는 것 같지 않아서 zero-install이 그렇게 필요한 상황은 아니었습니다. 

이런 이유와 당시 직전 프로젝트에서 peer depenency 문제를 해결하는데 많은 시간을 썼던 경험이 누적되어서 
pnpm을 선택한 것 같다.
 

### pnpm 설명해주세요 

##### 효율적인 저장 
`pnpm` (Performant npm)은 `node_modules` 폴더를 사용하면서도 
프로젝트 별 저장소에 dependency를 모아서 설치한 후 중복되는 dependency가 있다면 참조하여 쓰는 형태로 디스크 공간을 절약할 수 있다.


##### 의존성 관리 
pnpm은 `flat한 node_modules` 구조를 사용하여 의존성 중첩을 막고 
(의존성 격리 ) 팬텀디펜던시를 막기위해 패키지가 선언하지 않은 의존성에 접근하지 못하게 합니다. 
각 패키지가 오직 자신의 pacakage.json에 명시된 의존성만 사용할 수 있게 합니다. 

 


# Node_modules 문제 
---
프로젝트에 필요한 각 패키지는 자신의 `node_modules` 폴더 안에 자신이 의존하는 패키지를 가지고 있습니다. 이는 의존성이 중첩되어 저장되는 구조를 만들고, 같은 패키지의 서로 다른 버전이 여러 위치에 중복해서 존재할 수 있게 합니다.
다른 라이브러리나 패키지가 동일한 의존성의 서로 다른 버전을 요구할 경우, npm은 각 패키지 요구사항을 충족시키기 위해 해당 의존성의 여러 버전을 `node_modules` 폴더 내에 중첩 구조로 저장합니다. 이는 프로젝트의 구조를 복잡하게 만들고, 때로는 버전 충돌로 이어질 수 있습니다.

> 즉 중첩된 구조로 여러 다른 버전의 패키지를 가지고 있을때 버전 충돌이 일어날 확률이 있다.