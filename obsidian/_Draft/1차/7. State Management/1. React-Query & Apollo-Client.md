
React-Query는 GET 데이터 패칭과 관련하여 강력한 캐싱과 동기화 기능을 제공하는 라이브러리

React-Query의 캐싱 동작을 이해하기 위해서 `staleTime`과 `cacheTime` 두 가지 개념을 알아야 합니다.
- `staleTime`
	`staleTime`은 데이터가 `fresh` 상태로 유지되는 시간을 정의합니다. 이 시간 동안에는 데이터가 변경되지 않았다고 가정하고, 캐싱된 데이터를 재요청 없이 그대로 사용할 수 있습니다. 
	즉, `staleTime` 동안은 데이터가 최신 상태로 간주됩니다.
	
	HTTP 캐싱에서 이와 유사한 개념으로 `max-age` 디렉티브가 있습니다. `Cache-Control: max-age=seconds` 헤더는 캐시된 응답이 신선하게 유지되는 최대 시간을 초 단위로 지정합니다. 이 시간이 지나면 캐시된 데이터는 더 이상 신선하지 않게 됩니다. 그래서 조건부 GET을 통해 재검증 요청을 보내게 되는거지
	
- `cacheTime`
	`cacheTime`은 데이터가 캐시에서 완전히 제거되기 전까지 유지되는 시간을 정의합니다. 즉, 컴포넌트가 언마운트되거나 더 이상 사용되지 않는 데이터도 이 시간 동안은 캐시에 남아있어, 동일한 요청이 다시 발생하면 빠르게 캐시된 데이터를 제공할 수 있습니다. `inactive` 상태의 데이터가 이 시간 동안은 캐시에 보관됩니다.

위의 StaleTime과 CacheTime와 연계되어 React-Query에서 데이터에는 3가지 상태가 존재하게 되고 
이 상태에 따라서 캐싱과 동기화(refecth)가 일어난다.
1. `fresh` : 신선한 상태로 데이터를 그대로 사용할 수 있는 상태를 의미한다.
2. `inactive` : 현재 컴포넌트에서 사용중이지 않은 데이터를 의미한다. 
	- cacheTime이 지나지 않았다면, 다시 마운트되었을 때 cache 데이터를 불러온다. 
	- 대신 mouted되었을때 stale/fresh 여부에 따라서 재조회가 될 수 있다.
3. `stale` : 신선하지 않은 상태로, `stale` 한 데이터는 기본적으로 백그라운드에서 업데이트 된다.
	- staleTime이 지났을때 백그라운드에서 재조회한다.
	- `Refecth on Window Focus` 나 `Refetch on Reconnect`의 조건에서도 데이터가 stale하지 않으면 재조회를 하지 않는다.

> Apollo-Client와 달리 React-Query는 Mutation 데이터를 캐싱하지는 않지만
> 캐시를 업데이트하거나 무효화 하는 방법들이 존재한다.

> **캐시 업데이트 방법**
> 
> 1. **onSuccess / onError / onSettled 콜백**
>    Mutation이 성공하거나 실패했을 때, 혹은 처리가 완료되었을 때 호출될 콜백 함수를 정의할 수 있습니다. 이 콜백들을 사용하여 성공적인 Mutation 이후에 캐시를 수동으로 업데이트할 수 있습니다.
>    
> 2. **`invalidateQueries` 메서드**: 특정 쿼리의 캐시를 무효화하여, 다음 조회 시 강제로 서버로부터 데이터를 새로 가져오게 할 수 있습니다. 이 방법은 변경된 데이터가 다수의 컴포넌트에 영향을 미칠 때 유용합니다.
>    
> 3. **`setQueryData` 메서드**: 쿼리의 캐시된 데이터를 직접 수정할 수 있습니다. 이는 캐시에 있는 데이터를 바로 업데이트하여, 사용자 인터페이스를 신속하게 갱신할 때 사용할 수 있습니다.

> **캐시 무효화 방법**
> 
> 1. **`refetchQueries` 옵션**: Mutation 요청과 함께, refetch 해야 할 쿼리들을 지정할 수 있습니다. Mutation 완료 후 지정된 쿼리들은 자동으로 다시 실행되어, 캐시를 최신 상태로 갱신합니다.
>    
> 2. **Background Update**: 캐시 무효화 후, 사용자에게 바로 영향을 주지 않고 백그라운드에서 데이터를 업데이트하여, 다음 사용 시 최신 데이터를 제공할 수 있습니다.


 


# Apollo-Client
---

- GrahQL RestAPI 차이 


Apollo-Client는 GraphQL API를 사용하는 애플리케이션에서 데이터 관리를 위한 포괄적인 솔루션을 제공합니다. Apollo-Client의 캐싱 동작은 다음과 같습니다:.

1. **자동 캐싱**: Apollo Client는 쿼리를 실행할 때마다 결과를 자동으로 캐시합니다. 이후 동일한 쿼리가 실행될 때, Apollo Client는 네트워크 요청을 하지 않고 캐시된 데이터를 반환합니다.
2. **정규화**: Apollo 캐시는 데이터를 정규화하여 저장합니다. 이는 각 객체를 고유 ID에 매핑하여 저장함으로써, 데이터의 중복을 방지하고, 어떤 쿼리의 결과가 다른 쿼리의 결과와 겹칠 때 일관성을 유지할 수 있게 합니다.
3. **캐시 업데이트**: Apollo Client는 Mutation 실행 후 캐시를 자동으로 업데이트할 수 있도록 여러 전략을 제공합니다. 예를 들어, 캐시된 쿼리 결과를 직접 수정하거나, 특정 쿼리의 캐시를 무효화하여 다시 실행하도록 설정할 수 있습니다.

> 데이터 동기화 조건
> Apollo Client는 데이터를 최신 상태로 유지하기 위한 여러 조건과 설정을 제공합니다.
> 
> 1. **Polling**: 특정 간격으로 쿼리를 주기적으로 재실행하여 데이터를 최신 상태로 유지할 수 있습니다. 이 방법은 실시간성이 중요하지 않은 데이터에 적합합니다.
> 2. **Subscriptions**: GraphQL 서버가 지원하는 경우, Apollo Client는 WebSocket을 사용한 실시간 데이터 업데이트를 구독할 수 있습니다. 데이터가 변경될 때마다 서버로부터 업데이트를 받아 캐시를 자동으로 갱신합니다.
> 3. **Refetching**: 사용자의 특정 액션(예: 버튼 클릭)이나 애플리케이션의 상태 변경에 따라 쿼리를 다시 실행하여 데이터를 갱신할 수 있습니다.
> 4. **Cache Policies**: Apollo Client는 쿼리 실행 시 사용할 캐시 정책을 세밀하게 지정할 수 있습니다. 예를 들어, 항상 네트워크에서 데이터를 가져오거나, 캐시가 존재하지 않을 때만 네트워크 요청을 하는 등의 정책을 설정할 수 있습니다.
> 5. **Optimistic UI**: Mutation을 실행할 때 예상되는 결과를 캐시에 미리 반영하고, 실제 서버 응답이 도착하면 캐시를 업데이트하는 기법입니다. 이는 사용자 인터페이스의 반응성을 향상시키는 데 유용합니다.
