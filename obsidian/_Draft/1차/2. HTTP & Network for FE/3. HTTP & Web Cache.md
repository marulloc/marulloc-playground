
이미지 리소스를 포함한 모든 웹 리소스의 캐시를 일반적으로 "웹 캐시(Web Cache)"라고 합니다. 
이는 웹 브라우저가 웹 페이지에서 사용되는 리소스를 임시로 저장하는 메커니즘을 가리킵니다. 이러한 웹 캐시는 사용자의 브라우저에 의해 관리되며, 이전에 요청된 리소스를 다시 요청할 때 서버로부터 다시 다운로드하는 대신 캐시된 리소스를 사용하여 페이지 로딩 시간을 단축하고 네트워크 대역폭을 절약할 수 있습니다.


##### [3-1] HTTP 프로토콜에서 Cache와 관련된 헤더들에대해 설명해주세요 
---
https://toss.tech/article/smart-web-service-cache

#### Response Header
1. **Cache-Control**: 캐시 제어 지시어를 지정합니다. 다양한 지시어를 포함할 수 있다.
	- `max-age=[seconds]` : 캐시가 유효한 시간 결정
	  max-age를 사용하면 서버에 아예 요청을 보내지 않기 때문에 CDN의 캐시 버스팅 같이 어떤 일이 일어나도 브라우저의 캐시를 갱신해주기가 어렵다. 대신 시간이 만료되면 서버에게 재검증 요청을 보내게된다.
	- `no-cache` : "no-cache"는 캐시를 사용하지만 항상 서버에 재검증을 요청하는 것으로 사실상 `max-age=0`과 동일한 동작을 하게 된다.
	- `no-store` : 캐시를 절대로 해선 안되는 리소스일 때 사용한다. 이 지시어를 사용하면 브라우저의 어느곳에서도 해당 리소스를 저장하지 않는다.
	- `private` or `public` : CDN과 같은 중간 서버가 특정 리소스를 캐시할 수 있는지 여부를 지정하기 위해 Cache-Control 헤더 값으로 public 또는 private을 추가할 수 있습니다. public은 모든 사람과 중간 서버가 캐시를 저장할 수 있음을 나타내고, private은 가장 끝의 사용자 브라우저만 캐시를 저장할 수 있음을 나타냅니다. 기존과 max-age 값과 조합하려면 `Cache-Control: public, max-age=86400` 과 같이 콤마로 연결할 수 있습니다.
	- `s-maxage` : 중간 서버에서만 적용되는 max-age 값을 설정하기 위해 s-maxage 값을 사용할 수 있습니다. 예를 들어, Cache-Control 값을 `s-maxage=31536000, max-age=0` 과 같이 설정하면 CDN에서는 1년동안 캐시되지만 브라우저에서는 매번 재검증 요청을 보내도록 설정할 수 있습니다.
	- `must-revalidate` : 캐시된 콘텐츠의 유효기간이 지나면, 서버에게 콘텐츠의 유효성을 반드시 재확인하도록 요구

2. **Expires**: `max-age` **지시어** 대신 `Expires` 헤더를 사용하면 캐시가 만료되는 `절대시점`을 지정 할 수도 있다. 대신 Cache-Control 헤더가 존재하는경우 Expires는 무시될 수 있다.
3. **Last-Modified**: 리소스의 마지막 수정 날짜를 지정합니다. 이 헤더는 웹 서버가 리소스를 마지막으로 수정한 날짜를 클라이언트에게 알려줍니다.
4. **ETag**: : "ETag"는 리소스의 특정 버전을 식별하는 데 사용되는 고유한 식별자로 클라이언트와 주고 받으면서 캐시를 갱신해야되는지 판단하는 하나의 지표가 된다.

#### Request Header
1. **If-Modified-Since**: 클라이언트가 가장 최근에 받은 리소스의 수정 날짜를 서버에 전달하는 용도
   새로운 리소스나 최초에 리소스를 받았을 때, 서버가 전달해준 `Last-Modified` 헤더값을 가지고 있다가
   `Expires`에 명시된 시점을 지났거나 `max-age` 시간이 지났을때 브라우저가 이 헤더를 담아서 재검증 요청을 보내게된다. 만약 리소스가 변경되지 않았다면 304 Not Modiied 응답을 반환받게 되고 캐시된 것을 그대로 쓴다.
    
1. **If-None-Match**: 클라이언트가 가장 최근에 받은 리소스의 ETag 값을 서버에 전달하는 용도
   이전에 응답받은 헤더에 ETag가 있으면 브라우저는 재검증을 위해 예전에 받은 ETag를 헤더에 담아서 요청을 보내게 된다. 서버는 이를 사용하여 리소스가 변경되었는지 확인하고, 변경되지 않았다면 304 Not Modified 응답을 반환하고 브라우저는 캐시된 리소스를 그대로 쓰게 된다.

> 얘네들을 조건부 Get 이라고 부른다. 
> 근데 항상 재검증 요청은 하는것이 아니라, 
> 재검증 요청을 하거나 캐시에서 지우고 다시 재조회하는 등 캐싱 정책에 따라 바뀐다.



##### [3-2] 리소스의 캐싱이 어떤 순서로 이뤄지는지 알려주세요 
---
1. **브라우저 캐시** 확인 : 사용자의 브라우저는 가장 먼저 자체 캐시를 확인합니다. 이전에 방문한 웹 페이지의 리소스(예: 이미지, CSS 파일, JavaScript 파일 등)가 브라우저 캐시에 있을 경우, 캐시된 복사본을 사용하여 네트워크 요청 없이 리소스를 로드합니다.
    
2. **서비스워커 캐시** 확인 : 서비스워커(Service Worker)는 웹 애플리케이션, 특히 오프라인 경험과 백그라운드 동기화를 개선하는 데 사용되는 웹 API입니다. 서비스워커는 네트워크 요청을 가로채어(인터셉트) 캐싱 전략에 따라 캐시된 리소스를 제공하거나 네트워크 요청을 수행할 수 있습니다.
    
3. **CDN 캐시** 확인 : 콘텐츠 전송 네트워크(Content Delivery Network, CDN)는 전 세계에 분산된 서버 네트워크를 통해 웹 콘텐츠를 빠르게 제공합니다. 리소스 요청이 CDN을 통해 이루어질 경우, 가장 가까운 CDN 서버에서 캐시된 복사본을 제공하여 로딩 시간을 단축합니다.
    
4. **프록시 캐시** 확인 : 기업이나 학교와 같은 네트워크 환경에서는 프록시 서버를 통한 인터넷 접속이 이루어질 수 있습니다. 프록시 서버는 네트워크 요청을 중계하며, 프록시 캐시를 통해 자주 요청되는 리소스를 캐싱하고 제공할 수 있습니다.
    
5. **서버 요청**: 위의 모든 캐시 단계에서 리소스를 찾지 못했을 경우, 최종적으로 원래의 웹 서버에 리소스를 요청합니다. 서버는 요청된 리소스를 처리하고 응답으로 클라이언트에 전송합니다.




##### [3-3] Cache를 조작하는 방법에 대해 아는만큼 설명해주세요 
---
1. **코드 레벨에서의 캐시 조작**:
    - **Fetch 함수**: `fetch` API를 사용할 때, 요청의 `cache` 옵션을 통해 캐시 정책을 지정할 수 있습니다. 예를 들어, `cache: 'no-cache'`를 설정하면 요청이 캐시를 사용하지 않도록 할 수 있습니다. 이는 주로 클라이언트 사이드에서 작동합니다.
        - Node.js 환경에서는 `fetch` API가 기본적으로 제공되지 않기 때문에, `node-fetch`와 같은 외부 라이브러리를 사용해야 합니다.
        - Next.js에서는 데이터 가져오기를 위해 `getStaticProps`나 `getServerSideProps`와 같은 함수에서 `revalidate` 옵션을 사용하여 ISR(Incremental Static Regeneration)을 통한 캐시 유효 시간을 설정할 수 있습니다.
2. **서비스워커**:
    - 서비스워커는 네트워크 요청을 가로채 캐시 제어 로직을 구현할 수 있는 강력한 도구입니다. 개발자는 서비스워커를 사용하여 원하는 리소스를 프로그래밍 방식으로 캐싱하고, 오프라인 경험을 개선할 수 있습니다.
3. **서버 응답 헤더**:
    - 서버에서 HTTP 응답과 함께 `Cache-Control`, `Expires`, `Last-Modified`, `ETag` 등의 헤더를 설정하여 브라우저의 캐시 동작을 제어할 수 있습니다. 이를 통해 리소스의 캐시 유효 시간, 재검증 필요성 등을 명시적으로 지정할 수 있습니다.
4. **CDN 캐싱**:
    - CDN(Content Delivery Network)은 전 세계 여러 지역에 데이터 센터를 두고 콘텐츠를 캐시하여 제공하는 방식으로, 웹 콘텐츠의 로딩 속도를 크게 향상시킵니다. CDN 설정을 통해 리소스의 캐시 정책을 조정하고, 트래픽 분산 및 성능 최적화를 실현할 수 있습니다.
5. **프록시 캐싱**:
    - **리버스 프록시**: `로드밸런서`로써 사용하는 경우도 많지만, 리버스 프록시 서버는 클라이언트와 웹 서버 사이에서 요청을 중계합니다. 정적 콘텐츠를 캐시하여 직접 제공함으로써 웹 서버의 부하를 줄이고 응답 시간을 단축할 수 있습니다.
    - **포워드 프록시**: `VPN`용도로 사용하는 경우도 많지만, 포워드 프록시는 내부 네트워크의 요청을 인터넷으로 전달하는 역할을 합니다. 특히 학교, 기업, 기타 조직 등에서 네트워크 트래픽을 관리하고 비용을 줄이며 보안을 강화하기 위해 널리 사용됩니다. 포워드 프록시 서버는 클라이언트와 인터넷 사이에 위치하여 클라이언트의 요청을 대신해서 인터넷 자원에 접근합니다.




##### [3-4] 데이터 패칭 라이브러리의 캐싱 동작
---
> 프론트엔드 데이터 페칭 라이브러리의 캐시는 HTTP 헤더리는 것과는 다른 분야의 캐싱이다. 
> - 받은 데이터를 어떻게 저장하고 
> - 어떻게 동기화할 것이며 
> - Mutation이 발생하는 경우 어떻게 저장할 것인가
> 이런 작업을 도와주는 라이브러리 들
###### [3-4-1] React-Query 
[[1. React-Query & Apollo-Client]]
###### [3-4-2] Apollo-Client 
[[2.  API 설계 아키텍처 GraphQL vs RestAPI]]