

# [1] 프로젝트 기반 
---
 

- [ ] React 
	- [x] 특징
		- SPA - MPA : 페이지 이동마다 리로드, 서버 부하 등 이슈 해결, 백 프론트 분리 어려움 
		- Vue는 양방향 데이터 바인딩 -> react는 부모에서 자식으로 단방향 데이터 바인딩
		- VirtualDOM의 사용으로 실제 브라우저 렌더링 최적화 
			- diffing과정과 reconciliation 재조정 과을 이용
		- Fiber 아키텍처 
		- 모든 상태는 async / batch update


	- [x] Virtual DOM  
		- [x] 동작과정 과 장점
			- React가 실제 DOM을 추상화하여 메모리에 로드한 DOM 
			- 복사본 메모리/  상태업데이트 -> 새로운돔 / diffing / 재조정 
		- 메모리에서 빠르게 / 일괄 적 업데이트 / 반응성 좋은 웹 구현가능
		- [x] diffing 과정: diff 알고리즘
			- 엘리먼트 유형 / 속성(className id style) / 자식 비교 (key , 반복)
			- [x] key props 의 중요성 -> diff 알고리즘
				- key는 식별자/ 끼워넣는게 아니라 영향받는 애들 다시 렌더링하게됨
				- index값을 key로 넣어주면 안쓰는거나 똑같다. 정적인 배열이면 영향이 적겠짐나
				- 중복될 수 있는 값도 넣어주면 안된다. 

		- [x] Fiber 아키텍처 
			- React의 내부엔진 재설계 : block -> nonblock / 우선순위 / 작업 분할 -> 동시성모드를 쓸 수 있어짐 (선택적) + 웹 렌더링 성능 좋아짐
 
	- [x] React 18 버전 변화  
		- [x] Automatic Batching
			- 일괄 + 비동기 상태 업뎃 매우 중요 / 비동기 내의 상태 업뎃도 일괄 배치 처리 되게 만듦 
		- [x] Concurrent Mode + Fiber 아키텍처
		    - 렌더링 작업을 분할해서 
			- concurrent모드 활성화하면 / 컴포넌트마다 렌더링 우선순위를 정할 수 있음/ 필요한 경우 비동기적 작업 중단 및 재개 가능 / 중요한 UI 업데이트는 신속하게 나머지는 나중에 처리 가능
		- [x] HTTP Stream - Suspense - 서버컴포넌트  
			-  HTTP Stream - Suspense 아키텍처 -> 서버컴포넌트 이해해야함 
			- 페이지 요청이오면 -> 다 작업 시작됨 -> Suspense로 감싼 애들은 자식이 throw promise보고 fallbackUI렌더 -> 이런식으로 먼저 클라이언트에 데이터 전송 
			- Suspense로 감싸진 애들이 완성될때마다 다시 클라이언트에게 전송 -> 클라이언트는 뭐그 자리에 FallbackUI랑 진짜 컴포넌트랑바꿔치기 함 
			- 이게 SSR이면 HTML형태로 내려주지만 RSC면 JSON 형태로 스트리밍
			- [x] React Server Component
				- Server-side Rendering (SSR)
				- Concurrent Rendering : 비동기, 우선순위, 분한 렌더링 Fiber
				- Streaming SSR : HTTP stream을 이용 Suspense 단위로 클라이언트에 스트리밍 + selective hydration기술을 통해 부분적으로 업데이트 가능
				- Suspense : 코드스플리팅 을 통해 Streaming SSR 지원 

				 - 서버에서 렌더링됨 
				- 컴포넌트 트리 렌더링 할때 RSC는 렌더링, RCC는 placeholder 두고 tree를 직렬화된 json으로 바꿔서 / stream 형태로 전송 / 즉 컴포넌트 별로 렌더링 된다.
				- 직렬화 덕 / 번들 사이즈 대폭 감소
				 https://velog.io/@2ast/React-%EC%84%9C%EB%B2%84-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8React-Server-Component%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B3%A0%EC%B0%B0
			- [x] Suspense / ErrorBoundary 
				- https://www.youtube.com/watch?v=7mkQi0TlJQo
				- https://velog.io/@lky5697/suspense-in-different-architectures
				- https://velog.io/@shinhw371/React-suspense-throw
				- 목적과 쓰임
					- 코드 스플리팅 ? 
					- deta fetching - Fetch-on-Render 방식에서 Render-as-you-fetch 형태로 선언적 처리 가능
					- React Server Component의 Streaming SSR을 서포트하는 역할도 한다.
	
				- [x] Suspense / ErrorBoundary 는 어떻게 자식의 상태를 알 수 있을까 ?
					- 처음접했을 때  `lazy(()=> import()); ` 형태를 Suspense로 감쌌던걸 기 억한다. 이것으로 추론을 해보면 컴포넌트가 Promise 를 Return하면 Suspense의 Fallback UI를 보여주는 것 같다.
					- 또, React-Query 같은 페칭라이브러리도  훅을 통해 Promise를 반환할 것 같은데.. 음 훅 내부에서 리턴하는것을 부모 Suspense가 알아야하니까 
					- 결국 => Suspense는 `throw Promise`를 캐치해서 자식의 상태를 알게되는 것  같다. 그래서 nested한 형태로 Suspense를 작성 할 수 있는 것이 아닌가
					
					- [x] `throw` 지시어의 동작 방식
						- 특징 : 제어권 이동 (즉 콜스택 제어), 매개변수 전달
						- `throw`는 `Exception`이 아니라도 Object 기반의 객체면 모두 던질 수 있다.
			
						1. **에러 발생:** 함수 실행 중에 `throw` 문을 통해 에러가 발생하면, 현재 실행 중인 코드의 실행이 중지됩니다.
						2. **콜 스택 검사:** JavaScript 엔진은 현재 실행 컨텍스트에서 에러를 처리할 수 있는 `catch` 블록이 있는지 확인합니다. 현재 실행 컨텍스트 내에 적절한 `catch` 블록이 없으면, 해당 실행 컨텍스트는 콜 스택에서 제거(pop)됩니다.
						3. **상위 실행 컨텍스트로 이동:** 제거된 실행 컨텍스트의 바로 위에 있는 상위 실행 컨텍스트가 현재 실행 컨텍스트가 됩니다. 엔진은 이 새로운 현재 실행 컨텍스트에서 `catch` 블록을 찾기 위해 동일한 검사를 반복합니다.
						4. **`catch` 블록 발견:** 콜 스택을 거슬러 올라가는 도중 적절한 `catch` 블록을 발견하면, JavaScript 엔진은 에러를 해당 `catch` 블록으로 전달하고, 제어를 `catch` 블록으로 이동시킵니다. 이 때, `catch` 블록의 매개변수로 throw된  객체가 전달됩니다.
						5. **처리되지 않은 에러:** 만약 콜 스택의 모든 실행 컨텍스트에서   `catch` 블록을 찾지 못하면, 에러는 처리되지 않은 에러(uncaught exception)로 남게 되며, 이는 보통 프로그램의 비정상 종료로 이어질 수 있습니다.

			 
	- [x] 상태를 불변객체로 다뤄야 하는 이유 
		- 리액트의 상태 비교는 보통 얕은 함수라서 / 참조값이면 파악 못함
	- [x] React 애플리케이션의 성능 최적화 방법
		- [x] 최적화 (React.memo, useMemo, useCallback, code splitting, lazy loading)
			- 렌더링 :memo 고차함수 순수컴포넌트 / 객체 함수 리터럴 사용 자제 / 적당한 memoization 
			- 코드 스플리팅 : lazy + import() 
	- [x] useLayoutEffect, useEffect 
		- effect -> 비동기적 동작 : 재조정 과정이 끝난 직후 비동기로 호출
		- layout -> 동기적 동작 : 재조정 전에 동기적으로 실행됨 (즉 실제DOM적용을 Block 함)
			- 얘는 초기 렌더링때 즉시 반응하거나 바로 렌더링 되어 있길 바랄때 쓰면 될듯
	- [x] useRef
		- DOM직접접근
		- 리렌더링에도 유지되는 데이터


https://www.howdy-mj.me/next/hydrate
- [ ] Next.js
	- [x] Next.js는 무엇이고 어떤 장점이 있나요?
		- [x] 너는 왜 썼어요 ? - 프로토타입 만드는 과정 / concurrent mode + server component 등 격변하는 것 같아서 먼저 써봐야겠다는 생각 했다. 
		- [x] 어려웠던 점 -> Next13 RSC 동작 방식 이해하는데 힘들었다.  왜 함수는 넘어가지 않는가 

	- [ ] Next.js SSR, SSG의 동작원리에 대해 설명해봐라잉 
		- 결국 처음에 서버에서 만들어진 필요한 데이터는 미리 받아두고 만들어진 HTML 특히 클라이언트 코드는 플레이스홀더로 처리된 HTML을받아서 렌더링 먼저하겠네 약간 js 번들은 `<script defer>` 로되어있어서 미리 html 렌더링하고 js 로드가 완료되고 DOM에 미리받은 HTML이 다그려지면 JS 코드를 실행해서 플레이스홀더에 컴포넌트를 붙이는 하이드레이션 작업이 일어난다. 맞지 ?
		- 이게 Next13부터는 Selective Hydration, StreamSSR인거지 
			- Next13은 StreamSSR Selective Hydration 을 통해 Server-Component 를 지원 ??
			- https://velog.io/@hamjw0122/Next.js-Hydration#%F0%9F%A4%A0-react-18-streaming-html--selective-hydration

	- [x] getStaticProps와 getServerSideProps가 뭐에요
		- static : 빌드시점이나 revalidate 시점에만 호출되며 정적페이지 생성한다 (서버에서만 실행)
		- serverSide : 요청이 올때마다 호출되어 페이지에 데이터를 뿌려주는데 (서버에서 실행) SSR을 만드는 것으로 CDN에 캐시가 안되니까 조심하쟈
	- [x] SSR vs CSR vs SSG
		- CSR : 클라이언트에서 렌더링 / 빈 html, js bundle 로드 / js를 클라이언트에서 해석해나가면서 렌더링 /=> 초기 로딩은 느리지만 + 페이지 간 이동에 장점이 있음
		- SSR : 요청이 올 때 마다 서버에서 컴포넌트를 해석하여 html 을 렌더링해서 보내주고 js 보냄/ 클라이언트는 뼈대 HTML을 보여주다가 / js 해석이 완료되면 html에 붙임(하이드레이션) /=> 첫 페이지 로딩은 느리지만 페이지 간 이동에는 항상 통신이 발생 + 대신 js 로드하지 않고도 HTML 뼈대 존재 + 크롤러가 인식하기 쉬워서 SEO 강점 )
		  but : CDN에 캐시 안된다 ..
		- SSG : 빌드시간에 생성 / 정적인 데이터 / `generateStaticParams` 여러 정적페이지 생성가능
		- => Next.js는 기본적 SSG 동작 
	- [x] Revalidation 과 ISR 
		- revalidation : 빌드 시점에 생성된 SSG 페이지를 재생성 하게 해주는 것으로 아마 
		- 누군가의 페이지 요청이후 revalidate 시간이 지나면 새롭게 페이지를 빌드한다 
		- [x] On-demand Revalidation
			- **revalidate 과정을 필요에 따라 진행**하는 방식
			- API route에 요청을 route handler가 revalidate 를 진행하는 방식
 
	- [x] Next.js CDN 캐시 가능한가 ? 아니면 해결책은 ? runtime = edgeRuntime 
		- SSR 페이지는 CDN에 캐시될 수 없다. 항상 original Server까지 요청을 해야하는 문제를 해결하기 위해 Edge Computing이 등장했다. CDN과 같이  글로벌리 여러 지역 서버에 우리의 웹서버를 구축 할 수 있게 해줘서 SSR의 퍼포먼스를 크게 올릴 수 있다. 
			- [x] CDN vs Edge
				- CDN과 Edge Computing모두 a물리적으로 가까운 거리에 서버를 구축하여 빠르게 응답해주는 공통점은 있지만, CDN은 Runtime 환경을 지원하지 않고 단순 정적 파일을 빠르게 전송시키기만 한다. 
				- Edge는 물리적으로 가까운 거리의 웹서버 를 제공한다. 
	- [x] Next.js 성능개선 어떻게 ?
		- SSR 페이지나 RSC 를 사용하는 컴포넌트들 edgeRuntime에서 가동시켜 물리적 거리 단축
		- 이미지 사이즈 최적화..

	- [x] Next13을 쓰셨던데 어떠셨어요 
		- [x] 특징은
			- StreamSSR + Selective Hydartion + Suspense처리 쉬움  + RSC (zero bundle)
				- 단점은 이제 메모리 누수도 생각해야된다.. 어쩌구
				- 그 데이터페칭이 이제 컴포넌트 별로 형태가 달라진다..
					- 서비스함수와 파서를 잘짜야되고 뭐 규칙이 새롭게 필요해질듯
			 
		- [x] 어려웠던 점은  
			- 상태관리를 어떻게 해야될지 감이 안잡혔다. 
				- 서버컴포넌트에서 만약에 상태관리에 관여할것이면 초기화만
				- 데이터페칭이 이제 컴포넌트 별로 형태가 달라진다..
				- 상태에 따라 리프레시를 해줄거면 url에 queryString 으로 
				
			- [x] Next13 RSC 동작 방식 이해하는데 힘들었다.  왜 함수는 넘어가지 않는가 
				- 직렬화란 **특정 개체를 다른 컴퓨터 환경으로 전송하고 재구성할 수 있는 형태로 바꾸는 과정**이라고 할 수 있다. 우리가 흔히 사용하는 JSON.stringify함수가 바로 직렬화를 수행하는 함수이며, JSON.parse가 역직렬화를 수행하는 함수다 함수의 실행 컨텍스트, 스코프, 클로저까지 직렬화할 수는 없기 때문에 function은 직렬화가 불가능한 객체로 분류되는 것이다.

			- [x] 왜 RCS에서는 RSC를 직접 리턴할 수 없는가 (왜 children으로 받아야 하는가)
			- 서버에서 RSC가 실행되다가 중간에 RCC를 만나면 placeholder로 처리하고 넘어간다 즉 RCC는 실행되지 않아서 RSC가 리턴되지 않는다. 이런경우에 RSC로 작성했지만 클라이언트와 동일하게 동작하게 된다. 
			- 대신 children을 사용하면 공통 RSC가 렌더링될때 RCS밑의 RSC가 보이게되니까 서버에서 렌더링이 가능해지는 것 
		
		- [x] React-Server-Component 에 대해 더 자세히 알려주세요 
			 - [x] 왜 쓰는가 (장점)
				 - CSR의 초기로딩증가/ 큰 번들 -> SSR을 지원하면서도 클라이언트 코드와 비슷하게 고도화 된 것이 RSC 라고 생각한다. 
				 - 초기로딩속도향상 (렌더링 - 직렬화) / 작은 번들 (서버에서 렌더링 한 결과물이 반환) + 특히 RSC에서만 쓰는 라이브러리는 번들에 포함도 안됨
			- [x] 원리
				- 페이지 요청이 오면 서버는 컴포넌트 트리를 순회하며 직렬화된 JSON을 구성한다.
				  대신 RSC만 실제 렌더링하고 RCC는 placeholder를 두면서 렌더링한다. 이렇게 직렬화된 JSON을 
				  클라이언트에게 스트림 형태로 넘겨주는데 클라이언트에서는 컴포넌트 별, 페이지 섹션별로 컴포넌트 JSON을 받아 렌더링을 한다. 스트림이라 먼저 도착한 서버컴포넌트들은 기다리지 않고 먼저 렌더링 된다.
				  placeholder로 처리되던 RCC에 대한 번들을 받아 컴포넌트 트리를 완성하게 됨  
			      https://velog.io/@2ast/React-%EC%84%9C%EB%B2%84-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8React-Server-Component%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B3%A0%EC%B0%B0
			      
			- [x] RSC vs SSR 
				- 둘 다 모두 서버에서 렌더링 되긴 함 
				- RSC : 렌더링 이후 RSC Payload라는 JSON 형태의 스트림 형태로 으로 전송됨
				  즉 직렬화 되어 클라이언트로 전송하고 역직렬화해서 렌더링 => 초기로딩, 작은 번들 // 스트림을 이용해서 먼저 도착한 컴포넌트들은 미리 렌더링 가능 
					  - 메모리 누스 신경써줘야함
				- SSR : HTML이 전송됨
					- 단점 긴 컴포넌트들 모두 로드하고 페이지별 hydartion이 오래걸렸음
					- 페이지별 진입시점에 조금 느린 감이 있었고
					https://velog.io/@okko8522/RSC%EC%99%80-SSR%EC%9D%98-%EC%B0%A8%EC%9D%B4
	- [ ] _ Next.js의 Image / font 최적화 기능은 어떻게 동작하나요
		- https://blog.mathpresso.com/how-next-font-works-8bb72c2bae39
		- [ ] sharp  
	- [x] 국제화 지원 방법에 대해 설명해라 네 경험 해봤잖아
		- user-preference, geoIP + Negotiator / Middleware


- [x] Typescript 
	- [x] 특징 말해주세요 
		- 타입스크립트는 자바스크립트의 SuperSet으로 JS에 정적 타입 선언을 추가한 언어 입니다
		- TypeScript의 컴파일러가 코드 검사를 마치면 타입을 _삭제해서_ 결과적으로 "컴파일된" 코드를 만듭니다. 즉 런타임에 아무런 영향 없다.  
		- [x] SuperSet인 이유 
			- "상위 집합(Superset)"은 기존 집합의 모든 요소를 포함하면서 추가적인 요소나 기능을 제공하는 더 큰 집합을 의미합니다. JS 모든 동작이 가능하지만 거기어 정적 타입을 추가한거니까 
		- [x] 정적 타입 vs 동적타입 
			- 정적 : 변수의 타입이 컴파일 시간에 결정 -> 컴파일 시간에 타입 오류 발견 가능
			- 동적 : 변수의 타입이 실행 시간에 결정되며, 변수에 다양한 타입의 값이 할당될 수 있음  -> 유연성은 있으나 에러발생 확률 높음
	- [x] 왜 썼나요
		- 에코마케팅에선 APIDOC은 있어도 현재 내용을 반영하고 있지 않아서 혼동이 컸고 제가 입사할 당시 타입스크립트를 쓰지 않고 있었습니다.  
		- 데이터 흐름을 파악하기 너무어려웠고 유지보수벅찼다. API Doc이 없어서 또 유지보수나 컴파일단계에서 에러를 파악해야 그나마 나아질 것 같아서 타입스크립트 도입 
		- API 요청문들을 뽑아보면서 프론트엔드에서 타입스크립트로 API를 작성하고 그것을 기반으로 Pick이나 Omit 유니언을 작성하면서 나름의 Data Type들을 정의했습니다.
	- [x] 어떻게 썼나요
		- 개인적으로 오버로딩 될 수 있는 interface 보단 type을 이용하여 타이핑을 하며 
		- API 데이터를 타이핑 하기위해,  데이터들을 추상화해서 공통된 타입들을 만드려고 하는데 이때  `Record로` 정의하여 재사용해서 씁니다. 
		- 또 &로 타입들을 상속할 때 Pick과 Omit `유틸리티타입을` 많이 사용합니다.
		- 필요한 경우 타입단언이나 타입가드를 통해 타입이 끊어지지 않도록 노력하는 편입니다. 
		
	- [x] 타입체커가 하는일 
		- [x] 타입검사 
			- 변수와 표현식 타입 검사 
			- 리터럴 타입 추론
			- 함수 호출 문의 인수와 함수 선언에 명시된 매개변수 타입 검사, 제네릭 검사
		- [x] 타입호환 : (Duck Typing / 구조적 타이핑) 에 따른다
			- https://toss.tech/article/typescript-type-compatibility 
			- 타입간의 호환성을 판단하는 것
			- 타입 검사의 안정성과 유연함 사이에서 절충안으로 도입된 개념이 타입 호환성
				- 개발자 의도에 따라 유연하게 타이핑 가능
			- TS 는 오직 멤버만으로 타입을 관계 :
				- y가 최소한 x와 동일한 멤버를 가지고 있다면 x와 y는 `호환` 
			
			- [x] 명목적 타이핑 (Java) 과 차이
				- 명목적 타이핑은 타입 정의 시에 상속 관계임을 명확히 명시한 경우에만 타입 호환
				- 구조적 서브타이핑은 아래와 같이 상속 관계가 명시되어 있지 않더라도 객체의 프로퍼티를 기반으로 사용처에서 사용함에 문제가 없다면 타입 호환을 허용
	
			- [x] 타입호환 예외조건  `Fresh Literal`
				- 함수에 값을 바로 인자로 전달하는 경우만 타입 호환이 지원되지 않는다
				- 함수에 값을 바로 넘겨주는 것을 TS는 FreshLiteral 이라고 명명하는데
					- `fresh`
						- 모든 object literal은 초기에 “fresh” 하다고 간주되며, `타입 단언` (type assertion) 을 하거나, `타입 추론`에 의해 object literal의 타입이 확장되면 “freshness”가 사라지게 됩니다. 
						- 특정한 변수에 object literal을 할당하는 경우 이 2가지 중 한가지가 발생하게 되므로 “freshness”가코드를 읽는 다른 개발자의 입장에서 함수가 실제 다루는 것보다 더 많은 데이터를 받아들인다는 오해를 불러일으킬 수 있고, 프로퍼티 키에 대한 오타가 발생하더라도 오류가 확인되지 않는 부작용이 있다고 판단해서 TS는 freshLiteral은 타입호환을 지원하지 않음
						
			- [x] 타입호환 못하게하기 (Branding Type)
				- 의도적으로 `__brand` 와 같은 프로퍼티를 추가시켜, 개발자가 함수의 매개변수로 정의한 타입 외에는 호환이 될 수 없도록 강제하는 기법입니다.
				- `type Brand<K, T> = K & { __brand: T};` 
				- `type Food = Brand<{name : string },'FOOD'>`
		- [x] 타입추론
			- 타입 추론이란 타입이 정의되어 있지 않은 변수의 타입을 자동으로 추론하는 타입스크립트의 기능
			- 타입 추론 덕분에 모든 변수에 일일이 타입을 정의하지 않아도 되는 편리함을 준다.
				- [ ] 타입추론 가능한 상황
					- 변수 선언
					- 구조 분해 할당
					- 함수 반환 값
					- 기본값 설정된 매개변수 
			- 인터페이스 타입 추론
				- 각각의 interface로 이뤄진 객체 배열의 타입은 : 공통된 interface[ ] 형태로 추론됨
 
	- [x] 타입스크립트 잘 쓰기 
		- [x] 타입단언 : `as`
			- 타입스크립트가 **추론하지 못하는 타입을 개발자가 직접 명시해주는 문법** 
			- 타입 단언에도 조건이 있는데, `value as Type` 으로 표현된 단언식에서 
			  `value` 가 `Type` 의 슈퍼타입이거나 서브타입이어야 한다.
			- 다중단언
				- `const num = 10 as unknown as string;`
			- const 단언 
				- `let num 10 as const`
		- [x] 타입가드 : 
			- **유니온 타입을 사용**하면서, **복수의 타입들 중 어느 타입을 이용할 지 확신**을 주는 문법
			- 타입가드에 사용할 수 있는 문법 
				- `typeof`
				- `instanceOf`
				- `in` 
			- isType~~ 로 커스텀 타입가드 만들어서 써도 됨 
			- 
		- [x] Template Literal Type
			- https://toss.tech/article/template-literal-types
			- 템플릿 리터럴을 이용해 새로운 Type을 만드는 것 
			- 유니온 타입을 연결하여 타입을 중복 정의하는 것을 막을 수 있다.
	- [x] ___ 기본 질문
		- [x]  any 임시용, unknown, never, void  타입의 차이점과 사례는 뭐냐
			- never : 함수가 항상 throw 하거나 무한루프 빠지는 함수 
			- void : 아무런 값을 반환하지 않을때
			- unknow : 동적인 타입일때 
		- [x] 언제 enum 사용 사례랑 장점은 뭐냐  
			- 상수 값의 집합으로 사용 
				- 문자형 열거형으로도 가능  `enum DIR { UP = 'UP' , down = "DOWN" }`
				- 숫자형 열거형 가능 `enum AA { Mon, Tue } 얘네는 0과 1로` 
					- `AA.Mon`
		- [x] 조건부 타입은  
			- 삼항연산자처럼 쓰는것
				- `type IsNumber<T> = T extends number ? "Yes" : "No"`
				- `type Result1 = IsNumber<42>; // "Yes"`


	- [x] 얘네 먼저
		- [x] type vs interface
			- interface : extends로 확장 가능, 오버로딩 됨, 컴파일시 캐싱됨
			- type : 인터섹션으로 타입 확장 + 생성, &로 상속받을시 컴파일시 계속 연산됨
		- [x] 인덱스시그니쳐  `{[key: T]: U}` 와 `Record`,  
			- 인덱스 시그니처는 동적 데이터를 작성할 때 매우 유용하다.
			- 근데 모든 키 값을 허용한다는 단점
			- 특정 key는 다른 타입을 가질 수도 있을 때 수정 할 수 없음
			- 자동완성기능안됨
		- [x] 제네릭
			- **타입(Type)을, 그 클래스나 함수를 사용할 때 결정하는 것**
			- [x] `Record`
				- 키 타입에 유연성을 제공하는 제너릭 타입이다.
				- `type Vec3D = Record<'x' | 'y' | 'z', number>;` 
		- [x] 유틸리티타입
			- 유틸리티 타입은 이미 정의해 놓은 타입을 변환할 때 사용하기 좋은 타입 문법
			- `Pick` , `Omit` , `Partial
		- [x] 유니온타입 인터섹션타입
			- 인터섹션 : 인터섹션 타입(Intersection Type)은 여러 타입을 모두 만족하는 하나의 타입
			- 유니온 :  A이거나 B이다
			- [x] 유니온타입 주의할 점
				- 사실 유니온은 OR 처럼보이는데 OR 연산이 아니다. 
				- 함수 인자 하나에 유니온타입 `A | B` 가 넘어온다고 정의했을때 타입스크립트 관점에는 호출시점에 뭐가 올지 몰라서 , 둘다 되는 방향으로 타입추론이 이뤄져 에러가 발생하지 않는다. 그래서 마치 인터섹션 타입을 넘긴것 처럼 동작하는데
				- 이것을 해결하려면 `타입가드`를 사용하거나 `브랜딩타입`을 사용해야된다


- [x] 클라우드 
	- [x] AWS
		- [x] S3 / Cloudfront / Route 53
			- [x] 설명 +  어떻게 사용
				- S3는 스토리지로 정적인 것 저장 / 정적 웹 호스팅을 위해 html등 리소스 저장 가능
					- Jenkins에서 빌드한 후 aws cli로 S3로 push 해서 사용
				- Cloudfront는 CDN의 일종
					- S3 푸시하면서 aws cli로 캐시무효화 
				- Route 53
					- DNS 서비스를 담당 도메인 할당하는 용도로 씀 
		- [x] Amplify
			- [x] 사용한 이유
				- 모노레포 만들면서 기존 레거시 프로젝트부터 향후 SSR 까지 고려되고 있었음
				- 배포시스템의 유연성이 필요했음
				- platform as a service 가 리소스측면, 안정성 측면에 좋을 것
			- log 관리
			- 브랜치별 preview 제공
			- amplify.yaml 파일만 작성해주면 모노레포 쉽게 배포가능 (어디가 프로젝트 시작점인지)
	- [x] Vercel
		- [ ] 사용한이유
			- e-commerce 모노레포 - netflix처럼 접속국가별로 리다이렉트 해야했음
				- 국가별 상품 가격이 다르기 때문에 
			- 뿐만아니라 최초엔 프로토타입 개발단계였기 때문에 무료인 점 
			- platform as a service 가 리소스측면, 안정성 측면에 좋을 것
		- speed insight나 
		- log 관리 
		- 브랜치별 preview 제공
		- 클릭만으로도 배포가능 


- [x] 패키지 매니저 
	- [x] 패키지매니저가 뭔가요 ?
		- 패키지 설치 및 보안 및 의존성 관리 역할 
	- [x] pnpm
		- [x] 왜 썼나요 ( Vercel )
			- 이전에 yarn berry를 쓰고 있었음 
			- 글로벌 ecommerce 프로젝트 -> 국가별로 리다이렉션 필요 -> GeoIP 추출이 필요
			- GeoIP 추출 라이브러리들 비쌈 -> Vercel + Next면 middleware에서 그냥 추출 가능
			- 프로토타입으로 배포할 것이라 Vercel 배포가 무료이기도 해서 Vercel 선택
			- 근데 Vercel이 yarn berry는 정적배포만 지원 
			- 찾다가 디스크 공간 절약이 좋대서 pnpm을 선택 
		- [x] 설명 + 어려웠던 점
			-  `content-addressable file store` 
				- 하나의 공유 저장소를 만들고 모든 패키지를 이곳에 저장하고 
				- 각각의 의존성 파일에 hash id를 부여 (중복되는 패키지는 같은 hash id)
				- 심볼릭 링크와 하드링크를 이용해서 각 프로젝트에서 공유한다. 
					- 각각의 프로젝트내의 패키지는 공용저장소와 하드링크 됨 (공간 활용)
					- 패키지와 패키지의 의존하는 경우 프로젝트 node_module폴더 내의 파일끼리 심볼릭 링크로 연결
					
				- [x] 심볼릭 링크 vs 하드링크
					-  하드링크 : 이름은 다르지만 원본과 동일한 데이터블록(inode)을 가리킨다. 
						- 원본이 삭제되어도 하드링크는 파일에 접근가능
						- 파일은 모든 하드링크가 삭제될때까지 파일시스템에서 삭제되지 않음
					- 심볼릭링크 : 바로가기 파일인 것; 
 
	- [x] yarn berry 
		- [x] 왜 썼나요 ( AWS Amplify ) 
			- 배포시스템의 유연성을 위해 (레거시들과 모두 통합할 생각 / SSR 도 필요해보임)
			- AWS amplify 선택 -> 과금이 빌드시간에 결정됨
			- 과금 줄이고자 빌드시간 줄여야했고 zero-install / yarn berry 사용 결정
		
		- [x] 설명  
			- pnp 
				- PnP 모드는 `node_modules` 폴더를 사용하지 않고
				- 의존성 파일을 압축파일로 관리해서 디스크 공간도 절약하고 중복되는 경우 참조 
				- pnp.js 파일을 통해 압축파일의 정확한 위치 명시 -> runtime에 Node에게 직접 찾아서 메모리에 로드 할 수 있게 해준다. 
			- zero-install
				- 압축파일들을 github에 올려서 사용하게 되면 NodeModule에서 틸드나 캐럿에 의해 다른 버전이 다운받아지면서 다른 개발환경이 구축되는 것을 막을 수도 있다.
					- [ ] 틸드와 캐럿
						- 틸드(~): major . minor . patch 중 상위 patch  버전 
						- 캐럿(^): x.y.z 중  상위 minor 버전 
			
		- [x] 어려웠던 점 ? 
			- pnp 모드에서 peer dependency 문제에 크게 혼나봄
			- 기존에 자주 사용하던 라이브러리들 사이에서 peer dependency가 충족이 안되었다. 
			- 어떤 것은 peer dependency에 프로젝트보다 낮은 React 버전이 명시되어 있어 라이브러리 업데이트나 교체까지 하느라 많은 시간을 쓴 기억이 있다. 

			- => 근데 패키지 의존성을 처음 관리해봤는데, 이제껏 몰랐던 - 관심없던, 혹시 발생할 수도 있었던 리스크를 해결한 것 같아서 보람찼다.  

	- [x] npm 문제점
		- [x] 패키지 탐색 문제
			- NPM은 패키지를 찾지 못하면 상위 디렉토리의 node_modules 폴더를 계속 검색합니다. 이 특성 때문에 어떤 의존성을 찾을 수 있는지는 해당 패키지의 상위 디렉토리 환경에 따라 달라집니다.
		- [x] 유령의존성(암묵적 의존성) - hoisting
			- NPM 및 Yarn v1에서는 중복해서 설치되는 node_modules를 아끼기 위해 끌어올리기(Hoisting) 기법을 사용합니


- [x] Monorepo
	- [x] Turborepo
		- [x] 왜 썼나요 - Vercel 버셀 
			- 모노레포툴의 기능때문에 선택한 건 아님 /  
			- 간략하게 기존엔 yarn berry를 써야 해서 간단하게 yarn workspace
			- 신규로 만드는 모노레포 /  Vercel로 배포해야되는 상황이었는데 (geoIp / 무료)
			- Vercel / yarn berry를 정적배포만 지원 /  pnpm으로 선회
			- 다른 모노레포 툴 필요했는데, vercel에 배포, vercel의 Next 사용하니까 / Vercel Turborepo 사용하게 됨 
		- [x] 설명해달라 + 내가 느낀 장단점
			- 빌드 캐싱 + 증분 빌드 : 이전에 했던 빌드를 캐싱해서 빌드 속도 빠름 / 변경된 부분에 대해서만 빌드 진행
			- 원격캐싱 : 써보진 않았지만 이 빌드된 캐시가 원격으로 공유 가능하다고 합니다 
		- [ ] 
			- https://blog.mathpresso.com/qanda-frontend-monorepo-with-tbd-af752314d30f

	- [x] Yarn Workspace
		- [x] 왜 썻나요 (AWS Amplify)
			- 다른 모노레포와의 차별성보다는 프로젝트 문제 해결 과정에서 자연스럽게 선택 
			- AWS Amplify 로 배포시스템 결정 (다양한 프레임웍 사용중이었고 외부 서비스 니즈)
			-  빌드/배포 시간에 따른 과금체계 에서 비용 줄이기 위해서
			-  zero-install 을 사용하기위해 yarn berry로 패키지 매니저 결정
			- lerna 라던가 npm workspace도 있었지만 나는 모노레포로 단순히 묶는 것만을 노렸다.
			- yarn berry쓰는김에 간단하게 workspace 사용
		- [x] 설명해달라 + 느낀 장단점
			- 하나의 yar.lock 파일을 이용 / 모노레포 안의 모든 패키지 의존성 통합 관리 
				- 의존성 설치 최적화 / 중복된 패키지 다운로드 방지 
			- pacakge.json 파일에 workspaces 설정만 해도 사용 가능 
		- [x] 어려운 점은
			- yarn workspace 보다 yarn berry를 사용하는 것이 더 어려웠다. 

	- [x] yarn workspace랑 Turborepo 차이점은 뭐라고 생각해요 
		- yarn workspace는 주로 패키지 의존성과 프로젝트 의존성 연결에 초점을 맞췄다면
		- Turborepo는 빌드 성능 최적화에 초점을 맞춘 모노레포로 느껴졌다 .

	- [x] 모노레포 만들 때 고민했던부분 
		- [x] 브랜치전략
			- master 브랜치 쓰면/ 다른 프로젝트까지 재 배포 될 것 같아서 / mater 브랜치는 동기화용 혹은 공유라이브러리 업데이트 용으로 사용 
		- [x] husky - precommit 
			-  VSCODE에서 뭔가 검색할때 다른 app의 코드를 수정하는 경우도 꽤 있더라 .. ㅋㅋ 
			- 그래서 만약에 브랜치가 tossplace/ 시작한다면 tossplace 파일 왜에 다른 파일까지 커밋하려고 할때 push를 막았다. 
				- 한ㅁㅏ디로 git add . 모두 staging 하지 말란ㄴ 의미 ㅋㅋㅋㅋ
				- 근데 이건 git hook으로  할 수 있지 않았을까 .

	- [x] 공용라이브러리 만들때 고민한거
		- [x] 컴포넌트 라이브러리 
			- 제어흐름도 좀 가려서 편하게 쓸 수 있지만 / 확장은 쉽도록 추상화의 수준을 좀 낮춰서 개발
			- 보통 만들기 귀찮은 Dialog, Dropdown 같은 컴포넌트들을 위주로 구현 / 
		
			- 이것들 모두 children을 renderProps로 받아서 확장성을 추구해봤고 
			- 이해하기 쉽도록 각각의 하위 컴포넌트들을 조립하는 합성컴포넌트 형태로 작성했습니다. 
			
			- 확장성 고려하여 엘레멘트들의 기본 속성을 받을 수 있도록
			- 프롭스의 타입은 React.ComponentProps 를 확장해서 썼고 
			
			- 누군가는 시맨틱웹을 하고싶어 할 수도 있으니
			- 제네릭으로 React.ElementType 중 하나를 "as"라는 프롭스로 받아서
			- 컴포넌트 최상단 엘레먼트를 바꿀 수 도 있게 했다.	
		- [x] 유틸이나 API 라이브러리 
			- 타입정의에 최선을 다.  
			- 최대한 작은 함수들을 합성해서 라이브러릴 구축했으며 
			- 작은 함수들도 어디선가 편하게 쓸 수 있도록 구성해보려고 노력했습니다 .


- [x] 아키텍처 패턴
	- [x] 아키텍처 패턴 & 디자인 패턴 차이점 알려주세요 
		- 아키텍처 디자인 : 전체 시스템의 구조와 / 구성 요소 간의 관계 / 를 설계
			- MVC, MVVM , Flux
		- 디자인 패턴 : 개발 시 특정 상황에서 자주 발생하는 문제를 해결하는 패턴
			- 컴포넌트 설계 패턴
	- [x] MVC
		- 애플리케이션을 모델(Model), 뷰(View), 컨트롤러(Controller)의 세 가지 구성 요소로 분리
		
		- 규모가 커지면서  View가 다양한 Model을 동시에 업데이트 하고 
		- 업데이트된 Model들이 각각의 View들에게 데이터를 전달하여
		- 불필요하게 리렌더되는 성능 문제
		- 이런 양방향 흐름 덕분에 복잡성과 유지보수 어려움이 증가 

	- [x] Flux패턴
		- [x] 설명해주세요
			- MVC의 복잡성을 해결하기 위해 등장
			- Flux는 유저의 입력(Action)이 Dispatcher를 매개체로 삼아 Store(Model)에 전달
			- Store의  데이터를 변경한뒤 그 Store를 구독하고 있는 View가 업데이트 / 단방향 흐름
			- Flux는 데이터 흐름을 명확하게 하여 애플리케이션의 유지보수성을 향상
		- [x] 써보니 어려운점은?
			- Redux를 사용하면서 보일러플레이트가 많아진 것은 Redux-Toolkit으로 개선됨
			- 그래도 Recoil이 훨씬 개발하기에 수월하더라 ..


- [x] 리액트 컴포넌트 설계 패턴
	- [x] Container-Presentation
		- [x] 설명해주세요
			- Container -> 데이터 관리와 비즈니스 로직 / 보통  reactQuery 등 hook
			- Presentation -> 딱 View를 위한 상태와 엘리먼트들만 존재 보통 recoil hook 
		- [x] 써보니 장단점은 ? 
			- 컴포넌트 깊이가 깊어짐 그러나 관심사분리 측면에선 개인적으로 제일 좋다고 생각
			- 근데 컴포넌트마다 컨테이너가 많아지는 것 같아서 칠드런 렌드프롭스 형태로 만들어서 
			- 컴포넌트가 원하는 것만 쓰게 했다. 
				- 이러면 불필요한 렌더링이 일어날수도 있어서 모든 컴포넌트를 React.memo로 
				
	- [x] hooks도 쓰던데 이유는 뭔가요 
		- [x] 설명해주세요
			- 커스텀 훅은 특정한 로직을 캡슐화하여 코드의 가독성과 유지보수성을 향상시키고, 여러 컴포넌트에서 동일한 로직을 재사용할 수 있게 해준다.
	
		- [x] 써보니 장단점은 
			- hook 을 만들다보면 재사용성에 대해 깊이 더 생각하게 되는 것 같다.  개발적 마인드 셋 자체가 견고한 코드를 짜는 것 처럼 되더라 
			- 확실히 Container-Presentation의 상위 호환 버전인 것으로 느껴지지만
			- 복잡한 컴포넌트에서 상태 로직을 추적하기 어렵더라 
		
	- [x] RenderProps
		- [ ] 설명해주세요
			- 코드 재사용을 위해 함수를 props로 전달하는 방식입니다.
		- [ ] 써보니 장단점은 - 제어 흐름
			- View 기능을 제공하는 컴포넌트들 Dialog 같은 것은 Children을 RenderProps 형태로 받도록 구현하는걸 선호한다.
			- 추상화 수준은 낮아지지만 정말 복잡한 것은 감추면서, 제어흐름은 노출해서 동작 흐름을 파악하기 좋은 것 같다.
			- 다만, 코드 형태가 가시성이 좋지는 않은 거 같다. 

	- [x] Headless UI 패턴
		- [x] 설명해주세요
			- UI 로직과 스타일을 분리하는 방식입니다. "Headless" 컴포넌트는 UI가 없이 기능성만 제공하고, 사용자는 이를 활용해 자신의 UI를 구성할 수 있습니다.
		- [x] 써보니 장단점은
			- 모든 컴포넌트를 healess로 짜긴 리소스가 많이 투입되는 것 같다. 
			- 또, 재사용성 높고 어디서나 쓰이게 만들기는 난이도 높은 패턴이라고 생각이 되지만
			- 잘짠다면 UI로직과 View과 분리되어 유지보수가 더 쉬워진다. 
		
	- [x] 합성컴포넌트 패턴
		- [x] 설명해주세요
			- 작은 컴포넌트를 조합해 더 큰 기능을 구현하는 방식
		- [x] 써보니 장단점은 
			- 컴포넌트의 관심사를 명확히 분리할 수 있습니다.


- [x] 상태관리 
	- [x] 상태관리란 무엇인가요
		- **유저와의 상호작용을 위해, 상태를 조작하고 다루는 모든 작업**
	- [x] 상태관리에 신경쓰는 부분이 있나요?
		- 서버 상태 / 클라이언트 전역 상태 / UI 상태

		- 보통 클라이언트 전역상태는 Recoil 
		- 서버데이터는 따로 선호하는 기술은 없지만 
			- React-Query나 Apollo-Client를 사용합니다. 
			- 혹은 초기화할때만 필요한 서버데이터면 Recoil을 비동기로 초기화하거나 ServerComponent를 이용하여 Recoil 내려받는다. 

		- 컴포넌트를 제작할때는 
		- 관심사를 분리하기위해 Container-Presentation 패턴이나 hooks 패턴을 사용하며
			- Container-Presentation 을 쓸땐 Container에 서버 상태, 전역 클라이언트 상태를 두고 이를 조작하는 함수를 정의해서 Presentation에 props로 전달하며
			- hooks 패턴을 쓸땐 , 
				- 서버데이터는 useQuery나 Recoil 을 조합한 hook을 써서 서버 데이터 조작이라는 Hook을 명시하기위해 Get, Set과 같이 동작을 명시하고
				- 전역클라이언트는 Recoil 관련 훅이라는 prefix를 붙여서 만드는 편입니다. 
 
	- [x] 네트워크 예외처리는 어떻게하나요 ? 
		- 예외처리는 기본적인 비동기 데이터 흐름과는 구분하려고 하는 편인데 
		
		-  Error Boundary 활용
			- "최근에는 React의 Error Boundary를 활용하여 컴포넌트 트리 내에서 JavaScript 오류를 포착하고, 이러한 오류로 인해 애플리케이션이 완전히 무너지는 것을 방지하려고 합니다
			- Error Boundary를 사용함으로써,  오류 메시지를 보여주고, 문제가 발생한 컴포넌트 대신 대체 UI를 렌더링할 수 있습니다.
		- 이전에는 
			- Axios를 사용할 때,  공통적인 에러 처리 로직을 구현하기 위해 interceptor를 활용
			- 예를 들어, 서버로부터 4XX 또는 5XX 응답을 받을 경우 사용자에게 알림을 제공하기 위해 toast 메시지를 자동으로 띄우는 등의 처리를 합니다. 
		
	- [x] Apollo-Client
		- [x] 왜 썼나요
			- 먼저 백그라운드 동기화 기능과 데이터 레벨에서의 캐싱 정책
			- 비동기 상태를 따로 관리 안해도 되는 점에서 선호
			- 특히 Apollo는 데이터를 정규화하여 캐싱하고
			- Mutation 결과값도 자동 캐싱해줌
			- 옵티미스틱 UI 제공
			
		- [x] 설명해달라 + 내가 느낀 장단점
			1. **자동 캐싱**: Apollo Client는 쿼리를 실행할 때마다 결과를 자동으로 캐시합니다. 이후 동일한 쿼리가 실행될 때, Apollo Client는 네트워크 요청을 하지 않고 캐시된 데이터를 반환합니다.
			2. **정규화**: Apollo 캐시는 데이터를 정규화하여 저장합니다. 이는 각 객체를 고유 ID에 매핑하여 저장함으로써, 데이터의 중복을 방지하고, 어떤 쿼리의 결과가 다른 쿼리의 결과와 겹칠 때 일관성을 유지할 수 있게 합니다.
			3. **캐시 업데이트**: Apollo Client는 Mutation 실행 후 캐시를 자동으로 업데이트할 수 있도록 여러 전략을 제공합니다. 예를 들어, 캐시된 쿼리 결과를 직접 수정하거나, 특정 쿼리의 캐시를 무효화하여 다시 실행하도록 설정할 수 있습니다. 

			- 단점 
				- 쿼리에 하나라도 다른 것이 있다면 다른 데이터로 취급한다
				- endpoint가 하나라서 url마다 캐싱정책을 다르게 할 수가 없다
			- 장점
				- Mutation 결과값도 자동 캐싱해줌
				- 옵티미스틱 UI 제공

			
		- [x] GraphQL  
			-   고정 구조의 데이터 교환 방식을 해결
				-  REST API는 클라이언트 요청이 고정된 구조를 따라야 리소스를 수신할 수 있습니다. 이 엄격한 구조는 사용하기 쉽지만 필요한 데이터를 정확히 교환하기에 항상 가장 효율적인 수단인 것은 아닙니다.
			- 오버페칭 언더페칭
	- [x] React-Query
		https://programmerplum.tistory.com/179
		- [x] 왜 썼나요
			- 먼저 백그라운드 동기화 기능과 데이터 레벨에서의 캐싱 정책
			- 비동기 상태를 따로 관리 안해도 되는 점에서 선호
			- staleTime, CacheTime 을 조작해서 데이터 캐싱 을 조작할 수 있다는 점 
			
		- [x] 설명해달라 + 느낀 장단점
			- 상태 : fresh / inactive / stale
				- stale : staleTime 지나면 백그라운드에서 재조회 
				- inactive : 현재 컴포넌트에서 사용중이지 않은 데이터를 의미한다.
			- `cacheTime`은 데이터가 캐시에서 완전히 제거되기 전까지 유지되는 시간을 정의합니다
			- `staleTime`은 데이터가 `fresh` 상태로 유지되는 시간을 정의합니다. 

		- [x] 느낀 장단점
			- 장점 
				- refecth (재연결이나, 윈도우 포커스) 등 사용자 경험을 위한 디폴트기능
				- RTK에 비해 확연히 빨라진 개발
			- [x] Recoil과 함께쓸때 항상 경계가 모호해지는것 .. 
		
	- [x] Recoil
		- [x] 왜 썼나요
			- 보일러코드 없이 쉽게 전역 상태를 만들 수 있고 
			- atom의 비동기 초기화나 effects를 사용해서 동기화까지 가능하고
			- selector로 인해 atom의 파생값을 필요한 데이터만 분리 할 수 있어서 선호합니다. 
		- [x] 설명해달라 + 느낀 장단점
			- 공유상태(Shared State)도 React 내부상태(Local State)처럼 **간단한 get/set 인터페이스로 사용**할
			- 상태를 사용하는 컴포넌트에서 수정 필요없이, **상태에서 파생된 데이터**를 사용 가능하다. 또한, **파생된 데이터는 동기/비동기 모두 가능**하다.  		
	- [x] ReduxToolkit
		- [x] 왜 썼나요
			- 비슷한 도메인 데이터들이 한 파일에서 관리됨
			- 데이터의 흐름을 쉽게 파악할 수도 있었고
			- 미들웨어를 통해 예외처리나 로깅도 가능하고 편했다. 
			
		- [x] 설명해달라 + 느낀 장단점
			- 패턴을 따르는 상태관리 라이브러리입니다.
			- Redux Toolkit은 Redux의 보일러플레이트 코드 문제를 해결하고 

			- 단점
				- 확실히 코드량이 많고 좀 시작할땐 항상 버거운 느낌 
				- thunk가 반환하는 Promise 상태에 대해 일일히 다 extraReducer의 case를 작성해줘야 되었다.
				- 서버상태 클라이언트 상태 구분이 어렵다.
			- 장점
				- Recoil과 Redux Query에 비해 확실히 고민을 적게 해도 되는 것 같다.
				- 어디에 뭘 배치하고 고민 할 필요가 없는듯
		
		- [x] Flux 패턴이랑 ? 
			- MVC의 복잡성을 해결하기 위해 등장
			- Flux는 유저의 입력(Action)이 Dispatcher를 매개체로 삼아 Store(Model)에 전달
			- Store의  데이터를 변경한뒤 그 Store를 구독하고 있는 View가 업데이트 / 단방향 흐름
			- Flux는 데이터 흐름을 명확하게 하여 애플리케이션의 유지보수성을 향상
			
		- [x] Redux-Saga / Redux Thunk
			- Redux의 모든 과정은 **동기적으로** 발생하기 때문에, 비동기 통신을 통해 받아 온 결과값으로 state를 업데이트 하기 위해서는 외부 미들웨어 라이브러리를 사용해야 한다. 
			- [x] 왜 Thunk 사용하셨나요 
				- 간단한 비동기 작업이었기 때문에 러닝커브가 낮은 Thunk를 사용했습니다. 
				- thunk에서 반환된 함수를 reducer에 등록하여 각각 상태에 따른 처리 로직을 작성해주면 됩니다. 
			- [x] Saga
				- Saga는 액션을 모니터링 하고 있다가 특정 액션이 발생했을 때, 미리 정해둔 로직에 따라 특정 작업이 이루어지는 방식
				- Generator로 이뤄졌기 때문에 
					- 함수의 실행을  특정 구간에 멈추게 하거나 원하시는 시점으로 돌아가는 것 가능
					- 결과값을 여러번 리턴하게도 할 수 있습니다.
					-  `yield`를 사용하면 비동기 로직 뿐 아니라, 새로운 액션 발행(`put`), 동기적인 함수 호출(`call`) 까지 모두 차례대로 수행할 수 있도록 보장하여 예상치 못한 사이드 이펙트 발생을 줄입니다.
 

- [x] 스타일링 
	- [x] 전통적인 CSS
		- 외부`.css` + `<link>`
		- 내부 `<style>`
		- 인라인 `style 속성`
		- 단점 : 
			- 파일 위치를 파악하기 어렵고, 
		- 스타일이 전역으로 들어가서 구분하기가 어렵다. 중복개발도 많이하고
	- [x] CSS 전처리기 (CSS Preprocessor)
		- CSS전처리기는  CSS 코드를 쉽게 작성해주는 툴로 컴파일 타임에 CSS 파일이 만들어진다.
			- 자주 사용하는 스타일을 변수로 지정해 재사용 할 수 있어서 - 유지보수에 아주 좋음
			- 셀렉터를 중첩구조로 작성 가능 
			- Mixin 스타일 코드 재사용과 확장하기 쉽다더라			
	- [x] CSS 후처리기 (CSS Postprocessor)
		- CSS 후처리하는 것, 따라서 전처리기와 같이 쓸 수 도 있다.
		- 장점 
			- 자동으로 벤더 프리픽스를 추가해 주며, 브라우저 간 호환성 문제를 해결 (autoPrefixer)
			- 다양한 플러그인을 사용할 수 있다.
		- 단점
			- 플러그인과 설정 옵션의 어려움 
		- 예시 :  PostCSS 
		- 내 경험 Tailwind 쓰다가 autoPrefixer 쓰고싶어서 써본 경험.. 	
	- [x] CSS 모듈
		- Next.js가 기본적으로 지원하는거 
		- 클래스 네임 만들어야 딘다는 	
	- [x] 컴포넌트 스타일링 라이브러리  
		- [x] Utility-First CSS 방식
			- **미리 세팅된 유틸리티 클래스를 활용하여 HTML 코드 내에서 스타일링**
			- 유틸리티 클래스 : 
			- [x] Tailwind CSS  
				- [x] 장점
					- 스타일링에 필요한 대부분의 속성들이 클래스 형태로 사전에 정의되어 있고 사용자는 클래스들을 조합해요 사용하면 됩니다.
					- 클래스이름 고민하지 않을수도 있고 
					- `font-bold, text-sm` 같이 스타일과 동작을 한번에 정의하는 클래스를 사용
					- `단일 소스`를 제공 예를들어 config에 color #FFFFF 를 쓰면 이것이 border, background, text 등 색상관련한 속성에 적용되어 쓸 수 있다.
				- [x] 단점
					- 모든 CSS 속성 개별적으로 선언 : 인라인 CSS보다 길게 쓰임 ㅋㅋ
					- 직관적인데 가시성은 별로다 
					- 우선순위 문제 , bg-red-400 bg-blue-400 했을때 red 컬러가 나올 수 있음 - 같은 레벨일 경우에 tailwind 내부에 정해진 우선순위에 따라 스타일이 먼저 구상되기 때문이다. 
					- JS  변수 활용을 하려면 따로 유틸함수를 만들어서 써야된다. 
				- 내가느낀 장점
					- breakpoint와 스타일을 결합 해서 쓸 수 있어서 반응형도 쉽게 짤 수 있고
					- 그래도 스타일 컨벤션이나 디자인 시스템이 없는 곳에선 관리가 가장 용이한 CSS 라이브러리가 아닌가 싶다.  
				- [x] postCSS 사용 
					- tailwind 단독으로도 사용 가능  
				- [x] autoPrefixer : css 벤더 프리픽스 붙여주는 것으로 알고 있다. 				
		- [x] CSS-in-JS 방식
			- 타입스크립트 코드에서 직접 CSS를 작성하여 리액트 컴포넌트 스타일을 지정 가능런
			- 타임 CSS-in-JS는 단순하게 앱이 실행될 때 라이브러리가 스타일을 해석하고 적용
			- [x] 네 생각은 어때 왜 Emotion 버렸어 ? 
				- 장점 
					- 지역 스코프 스타일 
					- 코로케이션 : 컴포넌트에 관련된 CSS가 비슷한 위치에 있어서 스타일 파악 쉬움
					- 자바스크립트 변수를 style에 사용 가능
				- 알려진 바 단점 
					- 번들크기 
						- CSS-in-JS 라이브러리용 자바스크립트를 다운로드해야 합니다
					- 런타임 오버헤드 
						-  컴포넌트가 렌더링 될 때 CSS-in-JS 라이브러리는 document에 삽입할 수 있는 일반 CSS로 스타일을 “직렬화”해야 합니다. 
						  JS->CSS로 변환해야함
				- 내가 생각하는 단점 
					- CSS 가 관리가 전혀 안되고 있던 상황에, 차라리 컴포넌트로 만들어서 쓰자라는 생각으로 사용
						- 클래스이름에 대한 컨벤션 없고 그때그때 작성하고 있었음
						- 클래스 어디에있는지 파악하기 어렵고, 중복되는 경우도 많았음
						- padding, margin, text-size 에 대한 규칙 (디자인시스템) 없음
					- 근데 결국 
						- 컴포넌트로 다 만들 시간이 없더라.. 못생겨도 된단 마인드의 일정
						- 결국 padding,margin, text-size 이거 theme 설정안하면 힘들겠더라 결국 제각각으로 만들기 시작했음 
						- 규칙이 없으면 결국 CSS-in-JS도 해결책이 안되는것 같네.. 차라리 유틸리티 클래스 로 가서 걔네들이 기본 제공하는 스타일을 사용해서 관리를 최소화 해보자 !  
					
			- [x] Tagged Template Literals: `css`` ` 백틱을 이용하여 인자 전달
				- 함수 호출에 템플릿 리터럴을 사용하여, 문자열 처리를 보다 유연하게 할 수 있도록 합니다
				- 태그된 템플릿 리터럴은 함수 이름(태그)과 그 뒤에 오는 템플릿 리터럴로 구성됩니다.
					- 함수는 템플릿 리터럴 내의 `문자열과` `표현식을` 분석하고 처리할 수 있으며, 템플릿 리터럴 내부의 표현식은 처리된 후 최종 문자열로 합쳐집니다.
				- `function tag(strings, ...expressions) `
					- `strings` : 표현식 `${}`으로 split 배열 
				- `expression` : 표현식의 밸류 리스트 
			

- [x] 최적화
	- [x] 네트워크 최적화 방법 사용하신 거 알려주세요
		- CDN을 사용해서 캐시
		- Server Component 사용으로 번들 사이즈 줄임
		- 이미지 레이지 로딩 
		- shopify할땐 defer로 최초 화면 로드를 앞당김
	- [x] 렌더링 최적화 방법 사용하신 거 알려주세요
		- 순수 컴포넌트나  leaf node에 위치한 컴포넌트에 React.memo를 써서 불필요한 렌더링 막고
		- 최대한 객체 리터럴이나, 함수 리터럴을 props에 바로 넘겨주지 않도록 노력했고 
		- animation이 동작하는 시점엔 absoulte 포지션을 줘서 주변 노드의 리플로우 영향을 줄이려고 노력했다. 
	- [ ] 웹앱의 성능지표엔 뭐가 있나요 ?  
		- https://velog.io/@bumsu0211/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EB%A0%8C%EB%8D%94%EB%A7%81-%EA%B3%BC%EC%A0%95%EA%B3%BC-%EC%B5%9C%EC%A0%81%ED%99%94

  
- [x] Wepback / babel / Module

	- [x] 모듈 번들러
		- 모듈 번들러는 여러 개의 파일(모듈)을 하나 또는 몇 개의 파일로 결합(번들링)해주는 도구입니다.
		
		- [x] JS Module
			- [x] ESM (ES Module)
				- `import`와 `export` 구문을 사용 
				- ESM은 비동기적으로 모듈을 로드할 수 있어서, 주로 프론트엔드 개발에서 사용
			- [x] CommonJS 
				- Node.js를 위해 만들어진 모듈 시스템으로, `require()` 함수로 모듈을 불러오고, `module.exports`
				- 주로 백엔드 개발(Node.js 환경)에서 사용됩니다. 하지만, Webpack 같은 모듈 번들러를 사용하면 프론트엔드 개발에도 CommonJS 모듈을 활용
				- CommonJS는 동기적 로딩 방식
	 
	- [x] 트랜스 파일링 / 폴리필 / 프리셋 에 대해 설명해주세요  
		- 트랜스파일링은 
			- **특정 언어로 작성된 코드를 비슷한 다른 언어로 변환시키는**
		- 바벨 
			- JS 실행 환경마다 각자의 엔진, 각자의 JS 버전이 다른데 , 
			  다 다른 환경에서도 동일하게 실행 될 수 있도록 트랜스파일 하는 것
		- 프리셋 
			- 특정 목적을 위해 사전에 구성된 Babel 변환 플러그인들의 집합
			- @babel/preset-env 
				- ES6의 모든 문법을 ES5문법으로 변환하는 규칙을 담은 묶음
		- 폴리필 
			- 최신 웹 API나 JavaScript 기능이 구형 브라우저에서도 작동할 수 있도록 구현한 코드입니다. 즉, 브라우저의 기능을 "채워주는" 역할을 합니다.
			- `@babel/polyfill`
				- 아예 새로운 개념이라 구형 자바스크립트에서 변환할 수 없을 때, 그 빈 부분을 채워주기 위한 집합 Promise 같은게 처음 나왔을 때
 


# [2] 근본 예상 질문
---
https://amyhyemi.tistory.com/224
https://amyhyemi.tistory.com/224
- [ ] Javascript 
	- [x] Javascript의 특징이 뭐에요 ? (동적언어, Async, Non-Block)
	- [x] 실행 컨텍스트 
		- [ ] 실행컨텍스트가 뭐에요 ?
		- [ ] CallStack은 뭐에여 ?
		- [ ] 호이스팅 설명과 원리
		- [ ] 스코프체인 설명과 원리
			- ##### 렉시컬 환경의 계층 구조
				- **글로벌 실행 컨텍스트:** 처음에는 글로벌 실행 컨텍스트가 생성되고, 글로벌 렉시컬 환경이 이에 해당합니다. 이 환경은 전역 변수와 함수를 포함합니다.
				- **함수 실행 컨텍스트:** 함수가 호출될 때마다 해당 함수에 대한 새로운 실행 컨텍스트가 생성됩니다. 각 함수 실행 컨텍스트는 자신만의 렉시컬 환경을 가지며, 이 환경은 함수 내부에서 선언된 지역 변수와 함수 선언을 포함합니다.
				- **블록 레벨 스코프:** `if`, `for`, `while` 등의 제어 구문이나 `{}`로 명시적으로 생성된 블록 내에서 `let` 또는 `const`로 선언된 변수들은 해당 블록에 대한 렉시컬 환경을 생성합니다. 이 렉시컬 환경은 해당 블록의 스코프 내에서만 유효한 변수를 포함합니다.
				- => 그리고 각각 렉시컬은 자기가 정의된 곳의 부모 렉시컬을 참조한다. (외부렉시컬참조) + 한 실행컨텍스트에는 여러개의 계층적인 렉시컬 환경이 존재한다. 
			- ##### 스코프 체인
				- 변수에 접근하려 할 때, JavaScript 엔진은 현재 렉시컬 환경에서 시작하여 해당 식별자를 찾습니다.
				- 현재 렉시컬 환경에서 변수를 찾을 수 없는 경우, 외부 렉시컬 환경 참조를 통해 상위 렉시컬 환경으로 이동하고, 이 과정을 반복합니다.
				- 이러한 방식으로 스코프 체인을 통해 가장 가까운 렉시컬 환경에서부터 전역 렉시컬 환경에 이르기까지 순차적으로 검색하여 변수를 찾습니다.
		- [ ] 클로져 
			- [ ] 정의는요 ?
			- [ ] 어디서 활용되나요 (커링, 고차함수)
			- [ ] 구현 경험은요 ?
		- [ ] let, var, const 의 차이 
			- [ ] 스코프
				- 블록레벨스코프를 가지는  let const는 블록안에서 실행컨텍스트에 내부에 새로운 렉시컬 환경을 생성하며 똑같이 블록레벨 외부에 있는것을 외부 렉시컬 참조로 연결 
			- [ ] 참조 가능 시점 (호이스팅) (TDZ)
			- [ ] var 변수를 쓰면 안되는 이유 
		- [ ] 함수
			- [ ] 함수 호이스팅
			- [ ] 오버로딩 안되는 이유 
			- [ ] 인자가 어떻게 동작하나요 
				- [ ] arrow function은요 ? 
		- [ ] 즉시실행함수
			- [ ] 설명 원리 장점
			- [ ] 어디서 쓰일 수 있나요 ( 초기화 , 캡슐화 )
		- [ ] this
			- [ ] binding이 뭔가요 ?
			- [ ] this는 언제 결정되나요 ? 
				- [ ] arrow function은요?
	- [x] JS 엔진 구성을 알려주세요 (CallStack Heap, Macro,Micro,RequestFrames, EventLoop)
		- [ ] 비동기 함수가 동작하는 원리를 알려주세요 
		- [ ] Timer가 원하는 시간에 정확히 동작하지 않는 이유
		- [ ] setTimeout(0)을 해야하는 이유는요 ?

	- [x] 비동기
		- [x] 동기와 비동기의 차이가 뭐에요
			- 순차적이냐 비순차적이냐 
		- [x] callback
			- 다른함수의 인자로 전달 된 함수로
			- JS에선 함수가 일급객체이기 때문에 가능합니다. 
			- Promise가 없던시절 `onLoad`와 `callback` 을이용해서 비동기 처리
		
		- [x] Promise 객체 
			- 프로미스는 자바스크립트 비동기 처리에 사용되는 객체입니다.
			- 는 콜백 지옥(Callback Hell)을 해결하기 위해 등장
			
			- [x] Thenable (데너블) Promise 객체인가 ? 판단하기
				- `if (p instanceOf Promise) // const p = new Promise()` 
					- 이건 ES6를 지원하지 않거나, 프라미스를 사용하지 않고 구현한 Promise에 대해선 제대로 동작하지 않는다.
					
				- `obj != null && typeof obj.then === 'function';`
					- 모든 프라미스에는 `.then` 메서드가 있다. 그래서 
					- 사람들은 데너블 한 값은 프라미스다 라고 간주한다. 
			
		- [x] Promise와 async/await 차이 
			- `async/await`는 `Promise` 기반 비동기 작업을 동기적인 형태로 작성할 수 있게 하는 syntactic sugar
			- 굳이 Promise 써야되는상황
				- Promise.all Promise.reace

	- [x] 객체지향 
		- [x] 프로토타입 기반 언어 
			- 원형 객체를 복제하여 새로운 객체를 하는 생성하는 언어를 말한다
				- 대신 JS에서는 복제가 아닌 Prototype Link를 통해 원형을 참조한다. 
			- [x] 객체지향 언어
				- 객체를 생성하기 위해 클래스를 사용하고, 상속은 클래스 간에 이뤄짐

		- [x] `new` 의 동작방식
			- new 키워드를 이용하여 함수 호출하면, 그 함수는 단순한 함수가 아니라 
			- `생성자`로써 호출됨
			- [x] 생성자함수  
				- 생성자 함수가 실행될땐 this로 자기 자신을 바인딩하여  
				- 반환하는 인스턴스 초기화가 가능한 것 
		
		- [x] Prototype
			- 자바스크립트에서 단순 원시 타입(simple primitive)인 문자열, 숫자, 불리언, null, undefined를 제외한 모든 타입은 객체다.
			
			- [x] Prototype Link ( `constructor` , `protytpe` , `proto`  )
				- Function Object / Function Prototype Object
				- TOSS 함수를 선언하면 
					- TOSS라는  Function Object가 생성됨 (당연)
						- prototype 이라는 내부 프로퍼티가 존재 (참조용도)
					- Toss.Prototype Object 라는 것도 생김
						- Prototype Object는 이 함수의 `원형` 역할을 하게됨
						- constructor 라는 내부 프로퍼티가 존재 (참조용도)
	
					- Toss 함수 객체와  Toss.Prototype 객체 는 서로 상호 참조
						- 프로토 obj의 `constructor`로 ->  `Function Object` 참조
						- 함수객체의 `prototype`으로 -> `Prototype Object` 참조 
						- 1:1 로 참조하게 됨 
					
				- `new`로 함수를 생성자함수로 사용해서 반환된 "인스턴스"
					- 인스턴스는 생성자함수 (우리가 선언한 함수)에 의해 초기화
					- 인스턴스는 `__proto__` 로  -> `Prototype Object`를 참조
						- N:1의 관계로 참조하고 있음

			- [x] Prototype Chain
				- 우리가 배열을 만들면 배열의 메소드를 쓸 수 있는 이유가 뭔가 
			
				- JS 엔진이 함수가 실행될때는 식별자 해결 할때 스코프체인을 이용하지만
				- 객체의 내부에서 식별자 해결을 진행할 땐 `프로토 타입 체인` 을 이용한다

					- 함수를 선언한후, `생성자함수.prototyp.getName= ()=>{}` 를 써서
						- Prototype Object에 어떤 메소드를 생성해두면 
						- 인스턴스들은 이 메소드의 존재도 모른다.
				
					- 그러나 인스턴스들은 프로토타입 체인으로 메소드에 접근 할 수 있음
						- 객체 내부에서 식별자 해결을 진행하다가
						- 안되면 `__proto__` 가 참조하는 Prototype Object에서 메소드를 찾음

					- 메소드가 호출되면서 결국 호출 주체가 `인스턴스.getName` 이므로 
					- this가 인스턴스로 바인딩됨 

		- [x] class 문법 과 new Function 차이
			- 내부적으로 prototype 을 사용하는 것이라 class는 `syntactic sugar` 다.
			- 대신 정의 시점이 정적으로 메서드와 속성이 결정됨 
				- Prototype Object는 이용하면 동적이 가능했음
			- constructor 메서드로 초기화
				- 생성자 함수 역할

	- [x] Window 와 Document
		- [x] Window
			- `window` 객체는 브라우저에서 제공하는 글로벌 객체로
			- 브라우저 환경에서 동작하는 여러 API들의 가교 역할을 한다. document, history, location, setTimout, cookieStore 등 다른 브라우저 api에 접근을 제공한다.
			- 브라우저 탭에 대한 접근 권한
		- [x] Document
			- `window` 객체의 속성 중 하나입니다.
			- `document` 객체는 웹 페이지 그 자체를 대표하며, 페이지 내의 HTML 문서에 접근하기 위한 인터페이스를 제공합니다.
		
	- [x] 이벤트 버블링 캡쳐링 딜리게이션  
		- DOM 이벤트가  여러 DOM 들을 통해 전파되는 것인데 
		1. **캡처링 단계**: 최상위 노드에서부터 이벤트가 발생한 요소까지 이벤트가 내려갑니다.
		2. **타겟 단계**: 이벤트가 실제 발생한 요소(타겟)에서 이벤트 리스너가 실행됩니다.
		3. **버블링 단계**: 이벤트가 발생한 요소에서 시작하여, 최상위 노드 방향으로 이벤트가 올라갑니다.

		- [x] 버블링
			-  event target에서 최상위(document)까지 전파
			- 막으려면 StopPropagation
				- 버블링을 통해 event delegation 처리 가능 
		- [x] 캡쳐링
			- DOM Tree 최상위(document)에서 event target까지로 전파
			- addEventListener의 세번째 인자에 true해야 캡처링 활성화 
			- 타겟에 도달하기전에 인터셉트 하는 용도 
			
	- [x] event.target 과 event.currentTarget
		- [x] currentTarget
			- 이벤트가 등록된 요소
			- 이벤트 딜리게이션 될때 사용 , Form에서 onSubmit 같은 곳에서 사용
		- [x] target
			- 이벤트가 발생한 요소
			


- [ ] HTTP 
	- [x] HTTP 
		 - 웹에서 데이터를 교환하기 위한 프로토콜
		 - Stateless 프로토콜
		 - Connectless
	- [x] URL URN URI
		- [ ] URI 
			- URI는 인터넷 상의 자원을 식별하기 위한 표준 체계
			- 그 하위 방법으로 URL과 URN이 존재
		- [ ] URL
			- 자원이 위치한 곳을 나타내며, 자원에 접근하기 위한 구체적인 주소
			- 프로토콜 + 호스트(도메인) + 포트번호
		- [ ] URN 
			- 자원의 위치가 아니라, 자원을 식별하기 위한 이름 
			- 자원의 위치가 이동하더라도 유지되는 식별자
 
	- [x] HTTP vs HTTPS
	- [x] HTTP 1.1 / 2.0 / 3.0 차이
	- [x] HTTP Cache 
	- [x] HTTP 상태코드
		- **1XX (조건부 응답)** : 요청을 받았으며 작업을 계속한다.
		- **2XX (성공)** : 클라이언트가 요청한 동작을 수신하여 이해했고 승낙했으며 성공적으로 처리했음을 가리킨다.
		- **3XX (리다이렉션 완료)** : 클라이언트는 요청을 마치기 위해 추가 동작을 취해야 한다.
		- **4XX (요청 오류)** : 클라이언트에 오류가 있음을 나타낸다.
			- 401 인증 - 인증 안됨
			- 403 인가 - 접근 권한
		- **5XX (서버 오류)** : 서버가 유효한 요청을 명백하게 수행하지 못했음을 나타낸다.
	- [x] HTTP Stream
		- HTTP 스트리밍은 서버로부터 클라이언트로 데이터를 지속적으로 전송하는 방식을 의미합니다. 이 방식은 큰 데이터나 실시간 데이터를 처리할 때 유용하며, 데이터를 여러 조각으로 나누어 순차적으로 전송함으로써 초기 로딩 시간을 단축하고,
		- [x] WebSocket과 차이
			- **단방향 통신:** HTTP 스트리밍은 서버에서 클라이언트로 데이터를 지속적으로 전송하는 단방향 통신 방식입니다. 클라이언트가 초기에 요청을 보내고, 서버는 그 요청에 대해 연속적인 데이터 스트림을 응답으로 보냅니다.
			- **HTTP 프로토콜 사용:** 기본적으로 HTTP 프로토콜을 사용하여 구현되며, HTTP/1.1의 "chunked" 전송 방식이나 HTTP/2의 스트림 기능을 통해 지원됩니다.

			-  **양방향 통신:** 웹소켓은 서버와 클라이언트 간의 지속적이고 실시간의 양방향 통신 채널을 제공합니다. 한 번의 핸드셰이크 절차를 통해 연결이 수립되면, 그 연결을 통해 양쪽 모두가 데이터를 주고받을 수 있습니다.
			- **웹소켓 프로토콜 사용:** 웹소켓은 HTTP와는 별도의 프로토콜(`ws://` 또는 `wss://` 스키마를 사용)을 사용하며, 보다 효율적인 데이터 전송을 위해 설계되었습니다. 웹소켓 연결은 HTTP 연결을 업그레이드하는 방식으로 시작됩니다.

	- [ ] REST API 
		- [ ] REST
			- 
		- [ ] 
	- [ ] GraphQL

	- [x] Session / Cookie / Token / JWT - , JWT나 세션 기반 인증 
		- [x] Cookie : 서버와 쿠키는 데이터 공유를 위한 매개체 
			- 서버가 클라이언트 브라우저에 데이터를 저장할 수 있음
				- 대신 브라우저꺼라 쿠키는 네이티브 앱에는 사용 할 순 없음

			- 보통 유저를 기억하기 위해 쓰임
				- response에 `set-cookie` 헤더를 받으면 브라우저가 저장하게됨
				- 브라우저는 그 url에 데이터를 보낼때마다 
					- 쿠키를 req 헤더에 담아서 보내게됨 
					- 즉 쿠키는 도메인에 따라 분리됨
			- 쿠키는 유효기간 존재
			- 인증 뿐만 아니라 여러가지 정보 저장 
				- 웹사이트 언어 설정 바꾸면 서버는 설정한 언어에 대한 쿠키를 주고 
				- 다음에 방문할때 쿠키를 같이 넘겨주면서, 서버는 그 기억한 쿠키에 대한 데이터를 가지고 줄 응답을 고려해보겠지 


		- [x] Session  : 유저를 식별하기 위한 방법
			- 보통 인증 / 인가 할때 쓰이는데 
			- HTTP는 stateless라 모든 요청이 독립적이라 요청을 할때마다 인증을 해줘야함
			- 이를 해결하기 위한 방법으로 Session과  Token (JWT) 등장 

			- Session
				- 로그인하면 아디 비번 서버로 전송 HTTPS로 보내겠지 
				- 서버는 로그인이 성공하면 유저 식별자 같은 것을 Session DB에 저장 
					- 세션마다 별도의 ID 가 존재
				- 세션 아이디를 쿠키에 담아 보내고 브라우저에 저장시키지 
				- 그래서 요청을 보낼때마다 세션아이디를 쿠키에 담아 서버로 보내게되고 
					- 서버는 쿠키에 담긴 세션 아이디를 보고 유저를 식별 

				- => 모든 유저를 세션DB에 저장하니까 오버헤드가 커지겠지 

		- [x] JWT
			- Session 방식으로 유저를 식별하는 것이 오버헤드가 커져서 이걸 해결하기 위해 등장
			- JWT 방식은 세션DB도 필요 없고 유저 인증을 위해 많은 일을 할 필요도 없음
			- JWT는 그냥 string임 서버에서 받아서 요청때마다 보내는 것은 똑같다. 

			- 로그인 성공한 유저 정보를 기반으로 JWT Token 생성하고 body 응답으로 준다. 
			- 요청 마다 JWT Token을 담아서 보내고 서버는 이 JWT Token이 유효한지 체크만 한다..

			- [x] JWT 는 어디에 저장할까 ? Cookie ? LocalStorage -- 흐음..
				- Cookie에 저장한다면
					- XSS 공격에는 안전하지만
						- 악의적인 js 코드를 피해자 웹 브라우저에서 실행시키는 것
						- 이걸로 브라우저에 저장된 정보 탈취 가능
					- CSRF 공격에는 안전하다. 
						- request를 가로채 유저인 척 백엔드 서버에  변조된 request를 보내는 것
				- LocalStorage에 저장한다면
					- CSRF 공격에는 안전하지만
					- XSS 공격에는 취약하다 

		- [x] 인증 인가 구현 경험 
			- HTTPS 로 유저 아이디 비밀번호 전송
			-  JWT Token을 리퀘스트 바디로 받음 (`accessToken refreshToken`) 
				- -> 로컬스토리지 저장
			-  API 요청할때마다 헤더 `Authorization: Bearer 웹토큰` 형태로 전송 
				- 보통 API를 한번 랩핑하거나 axios 인터셉터로 만들어서 한번에 처리 

			- 401로 AccessToken이 만료되었다는 응답을 받으면 
				- refershToken으로 AccessToken을 갱신하고 
					- -> 다시 저장하고
					- 실패했던 요청 다시 전송하거나 새로고침
				- 갱신 실패할 경우 로그인페이지로 이동 
			
			- 이 작업을 reduxToolkit 사용할땐 미들웨어에서 처리했음
			- 아닌경우엔 axios 인터셉터로 구현했음

	- [x] ___ Polling SSE WebSocket

 
 


- [ ] Browser
	- [x] 런타임이란 ? 
	- [x] 브라우저 아이콘을 클릭하면 벌어지는 일
	- [x] 브라우저에 URL을 클릭하면 벌어지는 일 (Network / 렌더링)
		- [x] 리플로우 와 리페인트
			- 리폴로우 :  뷰 포트 내에서 렌더 트리상 노드의 정확한 위치과 크기를 계산하는 과정 
				- 한 요소의 리플로우는 주변 요수의 리플로우와 리페인트를 유발한다. 따라서 최소화
				- width, height, t,b,l, r, m ,p ,border, position ..
			- 리페인트 :  레이아웃에 영향을 미치지 않는 요소의 스타일 변경
				- 리플로우보다는 부하가 적음, 리플로우 없이 리페인트만 일어나는 애들도 있음
				- visibility background , border-radius, color ...  
			- `transform`이나 `opacity`와 같은 속성은 repaint나 reflow를 발생시키지 않는다.
		- [x] 최적화 
			- 레이아웃 변화가 많은 요소의 경우 Position 속성의 값을 `absolute` 또는 `fixed`로 주면, render tree의 다른 요소들로부터 독립되어 영향 받는 주변 요소들을 없애 연산과 렌더링 과정을 줄일 수 있다. 
	- [x] Web Storage 
	
	- [ ] CORS
		- CORS 현재 도메인과 다른 주소에 리소스를 요청하는 경



- [ ] Debugging Flow
	- https://www.youtube.com/watch?v=hy28I3Km_gM
	- https://www.youtube.com/watch?v=IwC-BVM2_YQ&t=285s

 

- [ ] CSS
	- https://velog.io/@dnr6054/fe-interview-html-css
	- [ ] CSS 캐스캐이딩
	- [ ] Box Model
	- [ ] Stacking Context
		- [ ] 해결하려면?
			- React.Portal
			- isolate
	 - [ ] css 애니메이션과 js애니메이션의 차이를 아시나요?


- [x] HTML
	- [x] Sematic Web
		- 크롤링 봇 이겠지 
	- [x] async defer 
		- 브라우저는 HTML 파일을 읽어온 후, 위에서부터 아래로 한 줄씩 해석을 시작합니다. 그러다가 중간에 스크립트 파일을 마주하는 경우에는, 해당 파일을 모두 해석하기 전까지 나머지 HTML 렌더를 일시적으로 멈춥니다.
		- 웹 개발자들은 HTML의 `<body>` 태그가 끝나기 직전에 스크립트 태그를 몰아서 넣곤 했습니다.
			- `async` 스크립트는 **DOM 렌더 과정을 방해하지 않도록 비동기로 로드**합니다.
				- **오직 파일을 불러오는 것만 병렬로 실행**
				- 로딩을 마치게 된다면, 그 즉시 DOM 렌더를 멈추고 `async` 방식으로 불러온 스크립트 파일의 해석을 시작
				- 따라서 DOM에 접근하는 스크립트를 `async` 방식으로 불러오는 것은 권장되지 않습니다.
			- `defer` 비동기 로드  / 스크립트는 **선언한대로 실행 순서가 보장됩니다**.
				- `defer` 스크립트는 **모든 DOM이 로드된 후에야 실행**됩니다.

 


# [3] 이력서 프로젝트 설명 기승전결 
---
어떤 문제

어떤 해결책을 고안했고 

이렇게 기술을 선택했다 .




# [3] 코테 예상질문 
---
- [ ] 리팩토링
	- [ ] 단일책임원칙
	- [ ] 관심사 분리 
- [ ] 기능구현
	- [ ] 재귀함수 

##### more ....
- [ ] 재사용성
- [ ] 선언적인
- [ ] UX를 좋게하는 방법 ... 
	- [ ] 



# [4] JD 기반 예상 질문 
---
- [ ] 플랫폼과 관련된 업무(공통 서비스, 공통 라이브러리 구현 및 운영 등) 경험이 있다면 해당 업무를 진행하게 된 이유와 경험을 상세히 기술해 주세요.  
	- 공용 컴포넌트 리이브러리
	- 객기 부려본적 있다. 파일기반 라우팅 만들기 
	- API 라이브러리

- [ ] 고가용성의 확장 가능한 시스템을 설계하고 운영해 본 경험이 있다면 설계한 근거와 함께 관련 경험에 대해 상세히 기술해 주세요.  
	1. Shopify, 개발 보일러플레이트 모노레포 구축한거 
		1. 여기서 Pnpm질문 yarn berry질문 
		2. Flux (RTK), Container-Presentation (디자인패턴) 질문 나올듯 

- [ ] 대규모의 실시간 트래픽을 처리하는 시스템을 설계하고 운영해 본 경험이 있다면 설계한 근거와 함께 관련 경험에 대해 상세히 기술해 주세요. 
	1. 그런건 없고 단순하게 대규모 데이터를 다뤄본적이 있는데 그것도 결국 API를 페이지네이션해서 불러온 경험만 있습니다.

- [ ] 서비스를 운영하면서 겪었던 트러블슈팅 혹은 성능개선 경험이 있다면 구체적인 과정을 기술해 주세요
	1. 그 24/7 오토파일럿 얘기하면서 dark Theme 얘기할까 
		1. 사용자들한테 그거 잘 쓰고 계시냐 물어봣는데 
		2. 아 근데새벽에 확인하는데 눈뽕을 받는다.. 뭐지 다크모드 해뒀는데 
		3. Next.js로 만들면서 그 Hydration 직전에 미리 렌더링된






# 버려 - 시간되면 봐 
--- 



- [ ] 프로그래밍 패러다임
https://fe-developers.kakaoent.com/2023/230330-frontend-solid/
	- [ ] 클린코드
		- [ ] 설명해주세요
		- [ ] 어려운 점은 없나요 ?
	- [ ] 함수형 프로그래밍 / 선언적 프로그래밍
		- 노마드코더 
		- [ ] 설명해주세요
		- [ ] 어려운 점은 없나요 ?
		- [ ] 커링 / 부분적허용 함수 / 클로져 / 모나드 설명해주세요 
	
 

- [x] Next
	- [x] ___ 국제화 지원 방법에 대해 설명해라 네 경험 해봤잖아
		- [x] Negotiator / Middleware
 

- [ ] Javascript
	- [ ] ___ Garbage Collection
	- [ ] ___ Iterable Generator 
	- [x] Symbol
		- 고유하고 변경 불가능한 원시 데이터 타입입니다. 심볼은 객체 속성의 키로 사용될 때 유용하며, 이름 충돌 없이 속성 키를 고유하게 만들고 싶을 때 주로 사용됩니다.
	- [x] Proxy
		- `Proxy` 객체는 다른 객체에 대한 작업(속성 접근, 할당, 열거, 함수 호출 등)을 가로채고, 그 작업을 변경하거나 새로운 동작을 정의할 수 있게 해줍니다.
		
	- [x] 웹워커 와 서비스 워커의 장단점에 대해 알려줘
		- 추가 스레드에서 실행되므로 메인 스레드를 블록하지 않고 실행될 수 있다. 
		
		-  Web Workers 
			- 웹 워커의 수명은 자신이 속한 탭 
			- 웹 워커는 주로 UI block을 피하기 위해 무거운 연산이 소요되는 작업(AI, games, image encoding, etc)을 보조 스레드에서 실행하기 위해 사용된다.
		 -  Service Workers
			 - 서비스 워커는 활성 탭이 열려있지 않아도 백그라운드에서 계속 실행될 수 있다.
			 - 서비스 워커는 일반적으로 네트워크 프록시 같은 역할이나 백그라운드 작업, 캐싱, 오프라인을 처리하는데 사용된다.
		 
	- [x] 기본
		- [x] 타입캐스팅에 대해
			- 타입 캐스팅은 변수의 데이터 타입을 다른 타입으로 변환하는 과정
		- [x] === (일치연산자) 와 ==(동등연산자 : 형변환) 의 차이는요 
			- 동등연산자는 타입캐스팅 발생 - 값같으면 true
			- d일치연산자는 값과 타입이 같아야함
		- [x] 일급객체란
			- 변수나 데이터 구조 안에 담을 수 있고, 파라미터로 전달하거나 반환값으로 사용할 수 있으며, 동적으로 프로퍼티 할당이 가능한 객체
		- [x] 고차함수란
			- 다른 함수를 인자로 받거나 함수를 결과로 반환하는 함수입니다.
		- [x] 콜백함수란 
			- 다른 함수에 인자로 전달되어, 그 함수 내부에서 호출되는 함수입니다
		- [x] 부분적용함수
			- 원래 함수의 일부 인자만을 적용해 새로운 함수를 생성하는 기법입니다.
		- [x] 커링이란
			- 다중 인자를 가진 함수를 단일 인자를 가진 함수의 시퀀스로 변환
		- [x] strict mode 란 
			- JavaScript 코드에 더 엄격한 오류 검사를 적용하여, 실수로 발생할 수 있는 문제를 미리 방지하고, 보안과 성능을 향상시키는 방법입니다.
		- [x] null, undefined 
			- `null`은 값이 없음을 의도적으로 표현한 객체 값이며,
			- `undefined`는 값이 할당되지 않은 변수의 기본값입니다.
		- [x] Javascript Runtime이란 
			- JS는 단독으로 실행될 수 없는데 
				- JavaScript Runtime은 JavaScript 코드를 실행할 수 있는 환경


 

- [ ] Git 
	- [ ] git revert
	- [ ] git reset
	- [ ] get rebase
	- [ ] git mrege
	- [ ] get fetch 


- [ ] 자료구조
	- [ ] Hash Table 




# React 심화
---

- https://velog.io/@jiseung/Streaming-w-Suspense	
- https://velog.io/@hamjw0122/Next.js-Hydration#%F0%9F%A4%A0-react-18-streaming-html--selective-hydration
https://www.youtube.com/watch?v=JadWu4Ygnyc&list=PLpq56DBY9U2B6gAZIbiIami_cLBhpHYCA

- Fiber 아키텍처 
	- 배경과 목적
		- 기존 Stack 재조정 작업이 동기/ 하나의 큰 작업으로 이뤄져 중단할 수 없었고 
		- 렌더링 동안 Block되는 것을 막기 위해 등장 
		- Fiber 아키텍처는 작업을 나누고, 우선순위를 관리하고, 중단하고 재시작 가능

	- react 16에서 등장했지만 react18에서 useTransition 훅을 통해 제대로 쓰이기 시작
	
	- 



---
- react 구성요소
	- react core
	- renderder
		- react-dom  - 호스트 렌더링 환경 의존
		- 호스트(브라우저)와 리액트를 연결하는 역할
		- 리컬실러, legacy-event 패키지에 의존성
	- event
		- synthetic event 
	- scheduer
		- Task 비동기 실행 
	- reconciler 
		- fiber 아키텍처에서 VDOM을 재조정 담당  
		- 컴포넌트를 호출

- 용어
	- 렌더링 
		- 컴포넌트 호출하여 리턴된 react element를 VDOM에 적용(재조정)하는 것
		- 전체과정에서 1번 2번이 렌더링
			1. 컴포넌트 호출 return element
			2. VDOM 재조정작업 (렌더링)
			3. renderer가 컴포넌트 정보를 DOM에 삽입(mount)
			4. 브라우적 DOM을 paint

	- react element
		- 컴포넌트 호출시 return하는 JSX를 babel을 통해 react.cleateElement가 호출되어 받은게 react element 
		- 컴포넌트의 정보 (DOM에 삽입될 내용) 을 담은 객체
			- type, key, props, 정보
	- fiber
		- 파이버 아키텍처랑 파이버랑 구분해야된다. 
		- VDOM의 노드 객체를 부르는 이름이기도 하다 
		- react element 내용이 DOM에 반영되기 위해 먼저 VDOM에 추가되어야 하는데, react element에 컴포넌트의 상태, 라이프 사이클, 훅 등이 붙은 객체다 
---

- React
	- [ ] Fiber Architecture
		- [ ] Concurrency 
			- Parallelism: 평행성이란 두개 이상의 태스크를 동시에 실행 할 수 있음
			- Concurrency : 동시성이란 두개 의상의 태스크를 동시에 지원함
				- 여러작업에 대해 일시정지와 재가동을 반복하면서 작업하는 것  
			
			- Incremental Rendering (증분 렌더링)
				- 일시 정지 , 재가동을 위해선 `우선순위` 가 필요한데 
				- React는 작업 우선순위를 매겨서 중요한 것을 먼저 처리하고 덜 중요한 것은 나중에 처리한다. 
					- API 호출 응답처리, 
					- 버튼 클릭 처리
					- 애니메이션 업데이트 같은 것들 중 
					- 유저와 렌더링 작업들에 태스크 우선순위 를 매기고 
						- 어떤 것을 먼저 렌더링 할지 또 우선순위를 정해서 렌더링한다.
						- 이런 작업을 위해 React는 Fiber 아키텍처를 사용한다.

 
			- 재조정 
				- Fiber 는 재조정 알고리즘이며 
				- 그에 맞는 fiber 노드들을 가지고 있다. 
				
				- 기존의 Stack 재조정은 DFS 형태로 탐색하며 동기적으로 한번에 처리했다.
					- 따라서 큰 앱일 경우 메인스레드가 재조정에 투입되어 다른 앱은 무반응

				- Fiber 아키텍처
					- 증분렌더링 
					- 여러 프레임에 걸쳐 렌더링 작업
					- 특정 작업에 우선순위 매겨 작업들을 concurrency 하게 진행한다.
					- Fiber는 DFS처럼 단순한 탐색이 아니라 
						- 각 fiber 노드에 포인터로 child -> sibling 순으로 이동하고
						- 각 fiber 는 다음에 처리해야할 fiber를 가리키고 있어서 
							- 중단 이후 재시작이 가능하다. 
						- 각 fiber 들은 변경 사항에 대한 정보를 가지고 있다가 모든 fiber 탐색이 끝나면 한번에 DOM에 업데이트 한다. 

 

	- [ ] Fiber 아키텍처
		- Virtual DOM이 UI의 상태 변화를 최적화하기 위한 메커니즘인 반면, 
		  Fiber는 렌더링 작업의 실행을 관리하고 최적화하는 스케쥴러로 쓰인다.

		- 도입배경 
			- 기존 Stack 재조정 작업이 동기/ 하나의 큰 작업으로 이뤄져 중단할 수 없었고 
			- 렌더링 동안 Block되는 것을 막기 위해 등장 
			- Fiber 아키텍처는 작업을 나누고, 우선순위를 관리하고, 중단하고 재시작 가능

		- [ ] Fiber의 구조
			- 각각의 Fiber 노드는 컴포넌트의 상태 프롭스 등 모든 정보를 가지고 있다.
				- 또한 child fiber, sibling fiber를 가리키는 포인터
				- 변경사항 대한 정보까지 담고 있다. 
			- Fiber 트리는 2개가 있는데 
				- 현재 상태를 가진 fiber tree와 아직 반영되지 않은 tree가 존재한다.
		
		- [ ] Fiber의 재조정 알고리즘
			- Fiber는 재조정 작업을 2 단계로 나눠서 실행
			- [ ] `Render` 작업
				- 두개의 Fiber Tree를 비교하고 변경사항을 수집하는 작업
				- 
			- [ ] `Commit` 작업
	 



	- [ ] React Event 
		- DOM Event (리액트 개입 없이 핸들링하기)
			- DOM API를 이용하여 DOM Node Select
			- DOM Node에 addEventListener로 콜백함수 등록
		
		- React 이벤트 (syntactic event)
			- 리액트는 브라우저 호환(크로스 브라우징)을 위해 NativeEvent를 그대로 사용하는 것이 아닌 `SyntheticEvent` 객체를 이용해서 NativeEvent를 감싸는 방식
				- SyntheticEvent 안엔 NativeEvent, 해당 이벤트가 발생한 FiberNode 등의 정보가 담겨있음
			- 그래서 React는 `onclick`이 아닌 `onClick` 같이 리액트만의 핸들러를 받는 것 

		- React Event Handler
			- 모든 이벤트는 React root DOM Container에 (`<div id="root"/>`) 달린다.
				- 실제 e.nativeEvent.currentTarget을 찍으면 root Node가 찍힌다.
			- VirtualDOM(Fiber Tree)가 생성되는 시점에 모든 이벤트 핸들러가 붙는다.
				- 즉 유저가 보기 전에 이미 핸들러가 달려있다. 
			- 어떻게 핸들러가 동작할까? 
				- 이벤트가 발생하면 DOM Node가 어떤 FiberNode와 매칭되는지 확인
				- 찾으면 해당 FiberNode에서 RootNode까지 순회하면서

	- Fiber 아키텍처
	- VirtualDOM 
	- 상태 업데이트 Batch / Async 
		- 
	- React Susepnse
		- 데이터 페칭
		- 코드 스플리팅
		- SSR Feature
			- Selective Hydration
			- Stream HTML 

- ReactSuspense
	- 데이터 페칭 상태 
	- 코드 스플리팅 
	- SSR 기능 
		- Selective Hydration
		- Stream HTML



