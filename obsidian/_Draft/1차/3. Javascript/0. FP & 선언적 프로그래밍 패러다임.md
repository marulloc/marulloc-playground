
### [0-0] 정의
---
함수형 프로그래밍은 작은 `순수 함수`들로 구성된 로직을 통해, 
`데이터의 불변성`을 유지, `사이드 이펙트를 방지`하려고 하는 프로그래밍 패러다임입니다.
함수형 프로그래밍은  `선언적 프로그래밍 스타일을` 추구합니다.

`클로저`, `일급객체`로서의 함수, `모나드` 같은 자바스크립트의 특징이 함수형 패러다임과 궁합이 잘 맞는 것으로 알고 있으며, `고차함수`나 `커링`, `부분적용함수` 같은 기법을 사용하면 코드를 더 추상화하여 함수형 프로그래밍에 가까워 질 수 있습니다.

> 불변성 : 외부상태에 의존성 없음
> 선언적 : 추상화가 잘된 - 재사용성 높은
> 일급객체 : 함수가 일반객체와 동일하게 사용 가능
> 모나드 : ...`데이터를 처리하는 규칙이 포함된 컨테이너`
> 고차함수 : 함수를 매개변수로 받거나 함수를 리턴
> 커링 : 함수 커링은 여러 개의 인자를 받는 함수를 하나의 인자만 받는 여러 함수로 나누는 과정
> 부분적용함수 : 함수를 재생성하면서.. 몇개의 인자를 고정시켜두고 추후에 나머지 인자를 받는 함수






### [0-1] 선언적 프로그래밍이 뭔데요 ?
---
보통 명령형은 How에 집중하고  선언형은 what에 집중한다 라는 문구를 제일 많이 봤습니다. 
제가 가장 와닿는 말은 **명령형 코드에서 ‘어떻게’를 감추고 ‘무엇’만 노출하는 방식의 추상화**(리팩토링)

> ***추상화*** 
> 복잡한 로직은 가려서 핵심에만 집중할 수 있도록 하는것 

처음에는 함수로만 묶고 함수명 잘 작성하면 선언적인 프로그래밍 아니냐? 라는 생각을 했습니다. 
근데 지금도 좀 함수명이 제일 중요 한 것 같긴 합니다만 ㅋㅋ

보니까 
- 물론 사용하는 용례를 봣을때 무슨 용도인지 바로 이해가 되고 
- 코드라인간 순서 의존도가 없고 
- 재사용이나 확장 용이하고 
- 제어흐름이 안보일수록 선언적이고 추상화 수준이 높아진다.. 


#####  [0-1-1] 결국 개인적으로 이해하기에는 
> - 제어흐름이 가려져 있는 추상화가 되어있고
> - 이름만 봐도 무엇을   `***반환***`  할지 파악이되고, 
> - 재사용 하거나 확장하기 쉬운 코드를 작성하는 것이 선언적 프로그래밍이라고 생각하고 있습니다. 


##### [0-1-2] 선언적 프로그래밍/FP를 위해 어떤 노력 해봤는데요 ?

 1. 고차함수 사용 (map, filter, reducer)
	    파싱할때 최대한 for문은 피하고
	 1. 보통 key:value 형태를 array로 파싱할때나 array를 반대로 파싱할때 reduce를 쓴다. 
	 2. `Object.entries(some).reduce() 형태 / .reduce()


2. 함수나 컴포넌트를 리팩토링 할 때 최대한 단일책임원칙을 지키고 함수명을 그에 맞게 잘 작성하려고 합니다.
	[[0. Clean Code]]
	
##### [0-1-2] 선언적 프로그래밍/FP를 지향할 때 어려웠던 점 / 개인적 생각
 도메인에 대한 이해, 확장성이나 향후 방향성에 대해서 고민해봐야 추상화의 깊이가 정해지는 것 같더라 

근데 저는 항상 선언적인 혹은 추상화 수준이 높다고 이해하기 쉽다곤 생각하진 않습니다.. 
특히 컴포넌트 볼때 ㅋㅋㅋ 변수명이 중요하지 않나 .. 
그래서 일부러 추상화 수준을 낮추기도 한다. 

 





### [0-2] 모나드가 뭔데요 ?
---
- 값과 함께 연산을 체이닝하는 메커니즘을 제공하는 추상화 개념입니다. 부작용을 관리하고, 예외 처리, 비동기 작업 등을 우아하게 처리할 수 있습니다. Promise 

저도 아직 이해가 잘 되지 않는 개념인데요. 제가 이해한 바로는
`데이터를 처리하는 규칙이 포함된 컨테이너` 입니다. 

어떤 작업을 수행하고 그 결과를 안전하게 다루고 싶을 때 모나드를 사용하면, 
- `성공이든 실패든 그 결과를 일관된 방식으로 처리할 수 있습니다. `
- 또한, 모나드는 이러한` 연산들을 '연결'하는 규칙도 제공`하기 때문에, 복잡한 작업의 흐름을 쉽게 관리 할 수 있습니다.

예시로 Promise 를 들 수 있는데요 
`Promise`는 미래의 어떤 시점에 값이나 실패 이유를 제공하는 객체입니다.  
성공(`resolve`) 또는 실패(`reject`)의 결과를 가지며, 그 결과에 따라 다른 동작을 체이닝할 수 있습니다.

`Promise`를 통해, 비동기 연산들을 선언적으로 체이닝하고, 각 단계의 연산 결과를 안전하게 다루며, 에러 핸들링을 일관되게 할 수 있습니다.

```js
const fetchData = () => new Promise((resolve, reject) => {
    setTimeout(() => resolve("데이터 로드 성공!"), 1000);
});

fetchData()
    .then(data => {
        console.log(data); // "데이터 로드 성공!"
        return "다음 작업 수행";
    })
    .then(step => {
        console.log(step); // "다음 작업 수행"
    })
    .catch(error => {
        console.error("에러 발생:", error);
    });
```




### [0-3] 왜 클로져와 일급객체, 모나드가 함수형 패러다임에 도움을 주나요 ?
---
 
함수가 일급 객체라서 클로저와 모나드 같은 프로그래밍 패턴을 구현할 수 있습니다

클로저는 데이터의 불변성을 유지하고 사이드 이펙트를 최소화하는 데 중요한 역할을 하며, 
모나드는 복잡한 연산의 흐름을 관리하고 예외 처리를 간결하게 하는 등, 
선언적 프로그래밍을 지원합니다.






### [0-4] 고차함수, 커링, 부분적용함수가 왜 FP 도와준다고 말함?
---
함수 커링 : [[3. Function#^a321ea]]
부분적용 함수 : [[3. Function#^2e4a7d]]


고차 함수, 커링, 부분적용 함수는 코드의 선언적 표현을 강화하는 데 큰 도움을 줍니다.
##### 고차함수
  `for` 반복문 대신  `map`, `reduce`, `filter`와 같은 고차 함수를 사용해 배열의 각 요소를 변환함으로써, 
  "무엇을(What)" 할 것인지만 명시하고, "어떻게(How)" 할 것인지는` 고차 함수에 위임`합니다. 
  for문보다는 고차함수가 코드를 더 선언적으로 만든다고 볼 수 있습니다.

##### 커링 
여러 인자를 받는 함수를 단일 인자를 받는 함수들의 연쇄로 변환하는 기법입니다. 
커링은 함수의 재사용성을 높이고, 함수 호출을 더 유연하게 만듭니다.

함수의 특정 로직을 미리 설정해두고 필요한 곳마다 나머지 인자를 넣어가며 
여러 일을 하는 함수를 명확하게 호출 할 수 있습니다.


##### 부분적용 함수
함수의 일부 인자를 미리 적용하고 나머지 인자를 나중에 받을 수 있는 함수를 생성해 두는 기법인데
명확한 의도를 가진 작은 함수를 구성할 수 있게 합니다.