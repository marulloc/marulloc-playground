
> 선언단계 creation - 선언적환경레코드 즉 스코프에 식별자가 등록됨 (key만 등록)
>                - 함수 선언문은 좀 다르다 바로 선언단계에서 본체가 메모리에 올라거서 등록됨
> 초기화단계 - hoisting : undefined로 할당됨 식별자마다 
> 실행단계

### [3-0] Javascript의 특징 

##### 싱글스레드 
먼저 자바스크립트는 싱글스레드 입니다. 
실행 컨텍스트의 호출을 담당하는 콜 스택이 하나이기 때문에 싱글스레드라고 불립니다.

##### Nonblock-Async
자바스크립트는 싱글스레드를 극복하기 위해 비동기 Non-Block 의 특징을 가지고 있습니다.  
- ***Async*** : 비동기 프로그래밍은 특정 코드의 실행 완료를 기다리지 않고 다음 코드를 실행하는 방식입니다. 이는 작업이 완료되기를 기다리는 동안 프로그램이 블록(정지)되지 않도록 하며, 이를 통해 더 많은 작업을 동시에 처리할 수 있습니다. `코드가 순차적으로 진행되지 않음`
- ***Non-Block*** : 논블로킹 I/O는 입력과 출력 작업이 프로그램 실행을 차단하지 않도록 하는 것입니다. 자바스크립트에서는 네트워크 요청, 파일 읽기/쓰기 등의 I/O 작업을 비동기적으로 처리하여, 이러한 작업이 완료되기를 기다리는 동안 다른 코드를 계속 실행할 수 있습니다.` I/O 작업에 프로그램이 중단되지 않음`

##### JS는 컴파일언어인가 스크립트언어인가 
자바스크립트 엔진은 Just-In-Time(JIT) 컴파일러를 사용하여, 코드를 실행하기 전에  컴파일하는 기능을 포함하고 있습니다. 따라서 자바스크립트는 그 실행 메커니즘에 따라 스크립트 언어와 컴파일 언어의 특성을 모두 가지고 있다


> ***실행컨텍스트의 장점***
> 실행컨텍스트 단위로 메모리에 로드되어, 효율적인 **식별자 해결(IdentifierResolution)**이 가능. 
> 함수나 변수를 찾기 위해 현재의 컨텍스트를 벗어나 모든 메모리 주소를 탐색 할 필요가 없기 때문이다.





### [3-1] let, const , var의 차이는 
- 호이스팅 
	- var는 실행컨텍스트 초기화 단계 덕분에 호이스팅이 되지만
	- let과 const는 호이스팅은 되지만 Temporal Dead Zone 상태에 의해 참조시점이 제한된다.
- 스코프
	- **var:** 함수 스코프(function-scoped)를 가집니다. 즉, `var`로 선언된 변수는 선언된 함수 내에서만 접근 가능하며, 함수 외부에서는 접근할 수 없습니다. 하지만, `var`로 선언된 변수는 블록 스코프({}로 둘러싸인 영역)를 무시합니다.
	- **let과 const:** 블록 스코프(block-scoped)를 가집니다. 이는 `let`과 `const`로 선언된 변수가 자신이 선언된 블록({}로 둘러싸인 영역), 문(statement) 또는 표현식(expression) 내에서만 접근 가능함을 의미합니다. 이로 인해 `var`에 비해 더 엄격하게 변수의 스코프를 제한할 수 있습니다.





### [3-2] 블록레벨스코프의 원리
var 변수는 함수레벨 스코프를 갖는 반면
let const 변수는 블록레벨 스코프를 갖습니다. 

javascript 엔진이 블록을 만나게되면 새로운 렉시컬 환경을 생성하고 
그 환경 안에 있는 let과 const는 새롭게 생성된 렉시컬 환경에서 관리됩니다.

이때 javascript의 스코프체인은 안쪽에서 바깥쪽으로 향하는 매커니즘 덕분에 
블록 바깥의 영역에서 블록 안에 선언된 let과 const 변수에 접근 할 수 없게 됩니다. 




### [3-3] Hoisting 과 실행 컨텍스트 
- 정의 : 실행컨텍스트의 선언 단계 에서 scope 즉 선언적 환경레코드에 식별자가 등록되는 것, 메모리에 식별자가 로드되는 것을 말합니다. 
- 원리
	실행컨텍스트에 엔진 컨트롤이 들어오게 되면 (콜스택 가장 아래에 존재하게 되면)
	자바스크립트 엔진은 먼저 실행컨텍스트의 초기화를 진행한다.
	
	함수 내부를 훑으면서 선언문으로 작성된 `var 변수`와 함수들을
	이때 `선언적 환경 레코드` 와 `변수 환경 컴포넌트`에 key value 형태로 저장하는데 
	value는 undefined로 초기화 된다. 
	
	초기화가 끝나고 함수 실행단계에서 표현식을 처리하는 과정에서 
	이미 실행컨텍스트의 선언적 환경 레코드에 초기화 되어 있어 식별자 해결이 가능해 집니다.





### [3-4] let과 const는 호이스팅 되지 않는 원리는 ? (TDZ)
저는 실제로 let과 const가 호이스팅은 되지만 TDZ라는 것에 의해 접근 시점이 제한되는 것으로 알고 있습니다.

 실행 컨텍스트 초기화 단계에서 `let`과 `const` 변수를 스캔하고 선언적 환경 레코드에 키로 등록합니다. 하지만 `var`와 달리, `let`과 `const`는 이 초기화 단계에서 값을 `undefined`로 설정하지 않습니다. 
 대신, 이들 변수는 선언문에 실제로 도달할 때까지 Temporal Dead Zone(TDZ) 상태에 놓이게 됩니다. 
 이 TDZ는 변수가 스코프 내에 존재하지만 아직 접근할 수 없는 상태를 의미합니다.

초기화 단계가 끝나고 실행이 시작되었을 때 
`let` 또는 `const` 변수의 선언문에 아직 도달하지 않았음에도 해당 변수를 참조하려고 시도할 경우, 
JavaScript 엔진은 TDZ 상태에 있는 변수를 참조하려고 한 것으로 간주하고 참조 에러(ReferenceError)를 발생시킵니다. 

이러한 메커니즘은 덕에 let과 const가 호이스팅 되지 않는 것처럼 간주되며
이러한 참조 에러 덕분에 잠재적인 오류의 가능성을 줄일 수 있다고 생각합니다.





### [3-5] 함수 호이스팅과 실행 컨텍스트

함수 선언식은 호이스팅되며 함수 표현식은 호이스팅 되지 않는다.  

 
> JS에서 함수 오버로딩이 안되는 이유 => KEY:VALUE 형태로 저장되니까

##### 선언 단계

- **함수 선언문:** 실행 컨텍스트의 선언 단계에서는 환경 레코드(Environment Record) 내에 함수 선언문이 미리 처리됩니다. 이 단계에서 함수 선언문으로 정의된 `함수의 이름과 함수 본문이 환경 레코드에 등록 (바로 초기화까지 됨)`됩니다. 함수 전체가 이 단계에서 처리되기 때문에, 함수 선언문은 코드 상의 위치와 관계없이 어디서든 호출할 수 있습니다(이것이 호이스팅의 일부입니다).

##### 초기화 단계

- **변수 초기화:** 이 단계에서는 변수가 `undefined`로 초기화됩니다. 함수 표현식에 의해 생성된 함수(즉시 실행 함수 포함)가 변수에 할당되는 경우, 이 변수 역시 `undefined`로 초기화되며, 이는 함수 본문의 평가보다는 변수 자체의 초기화를 의미합니다.
- **함수 선언문의 본문 평가:** 실제로 함수 선언문의 본문(함수가 수행할 작업들)은 선언 단계에서 환경 레코드에 등록된 후, 함수가 호출되는 시점에 평가됩니다.

##### 실행 단계

- **함수 실행:** 실행 단계에서는 코드가 실제로 실행됩니다. 이때 함수 호출이 발생하면, 해당 함수에 대한 새로운 실행 컨텍스트가 생성되고, 호출된 함수의 본문이 실행됩니다.
- **함수 표현식(즉시 실행 함수 포함):** 함수 표현식은 그것이 코드 상에서 평가되는 시점에 함수 객체가 생성됩니다. 즉시 실행 함수의 경우, 함수 표현식이 평가되자마자 바로 실행되며, 이 과정에서 함수 본문이 평가되고 실행됩니다.


함수 표현식은 아직 undefined 라서 `is not function` 에러가 나는 것이다.
```js
function declaration () { return 'declaration' };
var expression = function () { return 'expression' };

console.log(declaration()) //=> OUTPUT : declaration
console.log(expression()) //=> OUTPUT : ERROR : is not a function
```




### [3-6] 함수 인자와 실행 컨텍스트 
함수가 호출되는 시점에 호출할때 인자들을 arguments 라는 객체를 만들어 인자들을 삽입한다.
이 arguments는 Array-like 객체로 실제 Array Built-in Object는 아니다. 

이 arguments 객체는 직접적으로 선언적 환경 레코드에는 저장되지 않지만
함수 내부에서 사용할 수 있는 지역변수 처럼 동작한다. 

근데 ES6 의 화살표 함수에서는 자신의 arguments를 생성하지 않고 부모의 arguments 참조한다고 한다..

> Argument가 순차적으로 맵핑되어 인자를 여러개 넘겨도 에러가 발생하지 않음
 



### [3-7] Scope Chain과 식별자 해결 

스코프는 식별자의 유효범위입니다.

함수를 실행할때 외부 스코프에 대해 접근 할 수 있는데 Scope Chain 덕분이다.
JS 엔진이 식별자 해결을 진행 할 때
내부의 Scope 즉 `선언적 환경 레코드`에서 선언을 찾지 못하면 
선언된 곳 즉 상위의 Scope를 순회하며 식별자 해결을 진행하는 매커니즘이 Scope Chain이다.

실행컨텍스트가 생성될 때 렉시컬 환경 컴포넌트의 `외부 렉시컬 환경 참조` 에는 이 함수가 선언된 곳의 Scope를 참조하도록 만들어 진다. 즉 함수의 부모의 Scope를 참조하게 된다. 

어떤 변수나 함수에 접근할 때 JS 엔진은 선언적 환경 레코드에서 이름을 찾다가 실패하면
외부 렉시컬 참조에서 변수를 찾게된다. 
또 여기서도 찾지 못한다면 외부 렉시컬 참조를 부모의 부모 Scope로 교체하는데 
이 작업을 반복하다가 Global Scope에서도 찾지 못하면 undefined를 반환하게 된다. 




### [3-8] Closure 와 Scope Chain

클로저는 내부 Scope와 외부 Scope , 즉 실행컨텍스트의 선언적 환경 레코드와 외부 렉시컬 환경 참조의 조합으로 이뤄진 환경이다. 

클로저는 함수가 선언될 때의 렉시컬 스코프를 기억하고,
JS 엔진의 식별자 해결 매커니즘을 이용하여
함수가 실행될 때 어디서 실행되든 그 스코프에 접근할 수 있게 해줍니다.

React에서 보면 HOC나 
한 hook에서 리턴하는 컴포넌트가 hook내부의 state를 쓰고 있는 경우에 
이 클로져를 이용하게 된다. 
```ts
function withExtraProps(WrappedComponent) { 
	return function(props) { 
		const extraProps = {extraProp: 'extraValue'}; 
		return <WrappedComponent {...props} {...extraProps} />; 
	}; 
}


export const useSteps = (initialStep: string) => {
	const [step, setStep] = useState<string>(initialStep);

	const Step = (props: { name: string; children: React.ReactNode }) => {
		return <>{props.children}</>;
	};

	const Steps = ({ children }: { children: any }): JSX.Element => {
		if (Array.isArray(children)) {
			const Target = children.find(child => child?.props?.name === step);
			return Target || null;
		} else {
			return children || null;
		}
	};
	return [Object.assign(Steps, { Step }), setStep] as const;
};
```




### [3-8-1] Closure 

- 클로져
	"클로저는 내부 Scope와 외부 Scope, 즉 함수가 선언된 실행 컨텍스트의 선언적 환경 레코드와 외부 렉시컬 환경 참조의 조합을 말합니다. 이러한 구조를 통해 함수는 자신이 생성될 때의 환경을 '기억'하고, 이 환경의 변수들에 접근할 수 있습니다. 클로저 함수가 반환하는 함수는 이러한 클로저의 성질을 가지며, 이를 단순히 '클로저'라 부르기도 합니다."

- 고차함수
	함수를 매개변수로 사용하거나 / 함수를 반환하는 함수 , 고차 함수는 인자로 받은 함수를 필요한 시점에 호출하거나 `클로저`를 생성하여 반환한다. 자바스크립트의 함수는 `일급 객체`이므로 값처럼 인자로 전달할 수 있으며 반환할 수도 있다.
	
- 커링
	커링은 여러 개의 인자를 받는 함수를 하나의 인자만 받는 함수 여러 개로 나누는 기법입니다.
	변환된 함수는 각각의 단계에서 하나의 인자를 받고, 다음 함수를 반환합니다. 이 과정은 마지막 인자가 전달될 때까지 계속됩니다.
	커링을 구현할 때 `클로저`가 핵심적인 역할을 합니다. 커링된 함수의 `각 단계에서 반환된 함수는 클로저를 형성하여 이전 단계에서 받은 인자를 '기억'`합니다. 이를 통해 최종적으로 모든 인자가 전달될 때까지 함수의 실행을 지연시키고, 모든 인자가 취합된 후 원래 함수의 로직을 실행할 수 있습니다.

- 클로저를 활용한 구현경험
	- debounce 함수나
	- children에 새로운 props를 넣어주는 HOC를 만든 경험이 있다.




### [3-9] IIFE 즉시실행함수 With Closure

즉시 실행 함수(IIFE, Immediately Invoked Function Expression)는 정의되자마자 즉시 실행되는 자바스크립트 함수 패턴입니다.

`그룹핑 연산자`는 소괄호 안의 표현식을 평가하고 결과를 반환하는데 이 안에 `익명함수`가 존재하면 
1. JS엔진은 소괄호 안을 평가하게 되는데 function 키워드로 인해 엔진은 함수 객체를 생성하고 반환하며
2. 이후 뒤에 따라붙은 소괄호에 의해 즉시 호출되면서 실행컨텍스트가 생성되고 콜스택에 push되면서 함수가 실행되게됩니다.

여기서 즉시실행함수는 표현식이며 익명함수기 때문에 부모의 Scope에 어떤 식별자로도 등록될 수 없으며 (선언되지 않음) 그에 따라 기존에 실행된 함수 객체를 다시 참조할수는 없습니다.  

1. **독립적인 스코프 생성:** IIFE는 함수로 감싸진 코드 블록을 즉시 실행함으로써, 이 코드 블록 내에 선언된 모든 변수와 함수는 IIFE의 지역 스코프 내에 존재하게 됩니다. 따라서 이들 식별자는 IIFE 외부에서 접근할 수 없습니다
2. **변수의 캡슐화:** IIFE 내부에서 선언된 변수들은 IIFE의 지역 변수로 취급되므로, 전역 스코프에 추가되지 않습니다. 이로 인해 전역 변수의 수를 최소화할 수 있으며, 전역 네임스페이스의 오염을 방지합니다.
3. **모듈 패턴의 구현:** 모듈 시스템이 표준화되기 전, IIFE는 모듈 패턴의 구현체로 널리 사용되었습니다. IIFE를 사용하여 모듈 내의 세부 구현 사항을 숨기고(캡슐화), 모듈의 공개 인터페이스만을 전역 스코프에 노출시킬 수 있습니다. 이는 모듈 간의 충돌을 방지하고, 코드의 재사용성과 유지보수성을 높일 수 있습니다.


 > 그룹핑연산자로 감싸지 않으면 어떤 일이 벌어지는가 ? 
 > 
 > 그룹핑 연산자(`()`) 없이 익명 함수를 즉시 실행하려고 시도하면 문법 오류가 발생합니다. 
 > 이유는 자바스크립트 파서가 `function` 키워드를 만나면 기본적으로 함수 선언으로 해석하는데 
 > 함수 선언은 이름이 필요하여 에러가 발생하게 됩니다. 
 > 
 > 그룹핑 연산자는 함수를 표현식으로 변환하는 역할을 합니다.  
 > 즉 엔진에게 표현식 내에서 함수를 평가해야 함을 지시하는 것입니다.

> 함수를 평가하다 ?
> "함수를 평가한다"라는 표현은 함수의 코드를 해석하고 처리하는 과정을 말한다.

> 즉시실행함수의 this도 일반함수처럼 얘가 호출되는 곳의 주체이니까 얘는 
> strictmode가 아닐때는 global scope를 참조하겠네? 
> 화살표 함수라면 즉시실행함수 특성상 바로 실행되니까 즉시실행함수가 존재하는 부모의 this를 상속해오고 ?


### [3-10] This Binding 과 실행컨텍스트

this는 함수나 메소드가 호출된 컨텍스트를 가리킨다.
따라서 this는 호출 시점에 결정된다.

호출 시점에 실행컨텍스트의  `this 바인딩 컴포넌트`가 호출 주체를 참조하게 되면서 
this가 호출하는 객체나 window로 바인딩된다.
즉 `this 바인딩 컴포넌트`를 통해서 내외부 말고 this에 바인딩된 객체나 전역의  Scope에 위치한 변수에 접근 할 수 있게된다. 

함수가 객체의 메소드로 호출되지 않았을 때 `this`의 바인딩은 실행 컨텍스트에 따라 다를 수 있습니다. 기본적으로, 일반 함수에서 `this`는 전역 객체(global object)를 가리킵니다(브라우저 환경에서는 `window`, Node.js 환경에서는 `global` 객체). 그러나 strict mode(`"use strict"`)에서는 `this`가 `undefined`로 설정됩니다.
 
`this binding 컴포넌트` 는 동적으로 결정되기 때문에 `call()` `bind()` `apply()` 를 이용하여 호출될 때마다 this로 참조할 객체를 변경 할 수 있다.
https://github.com/marulloc/Marulloc-study-note/blob/master/Javascript/022.%20THIS%20call()%20%26%20apply()%20%26%20bind().md


### [3-11] Arrow Function 과 This

화살표함수의 this는 렉시컬 this 바인딩이다. 

화살표 함수가 정의될때 JS 엔진은 
화살표 함수가 ***선언된***  렉시컬 컨텍스트의 this 값을 화살표 함수의 this 로 삼는다.  상속같이
즉 선언된 곳의 부모의 this와 화살표 함수의 this가 같다.

> 화살표 함수 내에서는 `this`가 어느 시점에서 평가되든, 그 `this` 값이 변하지 않습니다.

이렇게 `화살표 함수의 this는 정적으로 바인딩`되고 
정적바인딩에 의해 역시`call()` `bind()` `apply()`를 이용해 명시적으로 this를 변경할 수는 없다.
 

### [3-12] Global Object
https://velog.io/@marulloc/Execution-Context-8-Host-Object-Global-Object







```js
//var bookAmount = 321

function book(){
    var point = 123;

    function show(){
        var title = "자바스크립트";
        getPoint() //=> 123
        //this.bookAmount // => 321//
    };
    function getPoint(){ return point; };

    show();
};

book();
```

```
show 함수의 실행 콘텍스트 {
	    "렉시컬 환경 컴포넌트(LEC)" : {
		        "환경 레코드 (ER)" : {
			            "선언적 환경 레코드(DER)": {
				                title : "자바스크립트"
			            },
			            "오브젝트 환경 레코드(OER)" : { }
		        },
		        "외부 렉시컬 환경 참조(OLER)" : {
			            point : 123,
			            getPoint : function(){}
		        }
	    },
	    "변수 환경 컴포넌트(VEC)" : {},
	    "this 바인딩 컴포넌트(TBC)" : {
		        글로벌오브젝트window
	    }
}
```



### 1. 렉시컬 환경 컴포넌트 (Lexical Environment Component)

- **정의:** 렉시컬 환경 컴포넌트는 현재 실행 컨텍스트에서 사용되는 식별자(변수, 함수 선언 등)와 그에 해당하는 값, 그리고 외부 렉시컬 환경에 대한 참조를 포함합니다. 이는 스코프와 스코프 체인을 결정하는 데 중요한 역할을 합니다.
- **구성 요소:**
    - 환경 레코드(Environement Record): 현재 컨텍스트에 있는 모든 지역 변수, 함수 선언, 매개변수 등의 식별자 정보를 저장합니다.
    - 외부 렉시컬 환경 참조(Outer Lexical Environment Reference): 외부 스코프에 대한 참조를 저장하며, 스코프 체인을 형성하는 데 사용됩니다.

### 2. 변수 환경 컴포넌트 (Variable Environment Component)

- **정의:** 변수 환경 컴포넌트는 렉시컬 환경 컴포넌트와 유사하게, 변수와 함수 선언에 대한 정보를 저장합니다. 그러나 주로 초기 실행 단계에서의 상태를 담당하며, `var`로 선언된 변수의 호이스팅(hoisting) 특성과 관련이 깊습니다.

> 변수 환경 컴포넌트(VEC)와 렉시컬 환경 컴포넌트(LEC)의 초기값은 같다.

- **차이점:** 렉시컬 환경 컴포넌트와의 차이는 주로 함수 표현식과 `let`, `const`로 선언된 변수가 처리되는 방식에서 나타납니다. `var`로 선언된 변수는 변수 환경 컴포넌트에 포함되어 호이스팅 됩니다.

### 3. this 바인딩 컴포넌트 (This Binding Component)

- **정의:** this 바인딩 컴포넌트는 실행 컨텍스트가 활성화될 때 `this` 키워드가 가리키는 객체를 결정합니다. `this`의 값은 함수 호출 방식에 따라 달라집니다(예: 전역 컨텍스트에서는 `window` 또는 `global` 객체, 메서드 호출에서는 해당 메서드를 호출한 객체 등).
- **중요성:** JavaScript에서 함수나 메서드의 현재 실행 컨텍스트를 참조하는 방법을 제공합니다. 이는 객체 지향 프로그래밍에서 객체의 메서드 내부에서 객체 자신을 참조할 때 필수적입니다.

실행 컨텍스트의 이해는 JavaScript 엔진이 코드를 어떻게 실행하는지, 그리고 스코프, 호이스팅, 클로저와 같은 중요한 개념을 이해하는 데 핵심적인 역할을 합니다.








 

