## 3-1) 제너레이터(Generator)

```
function exampleFunction () {
	return 1
	return 2
	return 3
	return 4
	return 5
}
```

위와 같이 함수를 작성한다면, 우리는 이 함수에서 하나의 리턴 값만을 기대할 수 있습니다. 이 경우에는 1만 반환받을 수 있겠죠. 하지만 제너레이터를 이용하여 함수를 작성하면 이 반환값을 모두 받을 수 있습니다. 심지어는 특정 위치에 잠시 정지시켜둘 수도 있죠.

```
function* generatorFunction () {
	console.log('첫 번째 실행')
	yield 1;
	console.log('두 번째 실행')
	yield 2;
	console.log('세 번째 실행')
	yield 3;
	console.log('네 번째 실행')
	yield 4;
	console.log('다섯 번째 실행')
	yield 5;
}
```

제너레이터 함수를 만들 때에는 function* 이라는 키워드를 사용하여 만듭니다. 여기서 우리가 잠시 짚고 넘어가야 할 점은 제너레이터 함수와 제너레이터의 차이입니다. 엄밀히 말하면, 위에서 작성한 제너레이터 함수를 통해 제너레이터 객체가 반환됩니다.

위에서 또 한 가지 특이한 점은 yield 라는 표현일 것입니다. yield 는 제너레이터 함수의 실행을 일시적으로 정지시키며, yield 뒤에 오는 표현식은 제너레이터를 관찰하고 있던 호출자(caller)에게 반환됩니다. 쉽게 생각해서 일반함수의 return 과 유사한 것입니다. 즉, 제너레이터 함수는 yield 부분에서 특정 값을 반환하고 그 실행을 잠시 멈추는 것입니다.

그렇다면 이후에 이 함수를 마저 실행시키려면 어떻게 해야 할까요? 이는 next 라는 함수를 통해 구현할 수 있습니다.

```
generatorFunction.next();
```

yield 부분에서 함수가 특정 로직과 값을 반환한 후에 코드의 흐름이 멈추고 나면, 이를 다시 진행시키기 위해 위의 예시처럼 generatorFunction.next(); 을 입력하면 그 다음 yield 부분과 만나기 전까지 함수의 로직이 이어서 실행됩니다.

이러한 기본적인 제너레이터에 대한 개념을 가지고 Saga에 대해 알아보도록 하겠습니다.